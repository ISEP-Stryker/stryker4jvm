document.querySelector('mutation-test-report-app').report = {"schemaVersion":"1","thresholds":{"high":80,"low":60},"projectRoot":"/home/michael/Documents/Study/ISEP/stryker4jvm","files":{"stryker4jvm/src/main/scala/stryker4jvm/extensions/DurationExtensions.scala":{"source":"package stryker4jvm.extensions\n\nimport cats.data.Chain\nimport cats.syntax.foldable.*\n\nimport java.util.concurrent.TimeUnit\nimport scala.concurrent.duration.Duration\n\nobject DurationExtensions {\n  implicit final class HumanReadableExtension(val duration: Duration) extends AnyVal {\n    final def toHumanReadable: String = {\n      val units = Seq(TimeUnit.DAYS, TimeUnit.HOURS, TimeUnit.MINUTES, TimeUnit.SECONDS, TimeUnit.MILLISECONDS)\n\n      val timeStrings = units\n        .foldLeft((Chain.empty[String], duration.toMillis)) { case ((humanReadable, rest), unit) =>\n          val name = unit.toString().toLowerCase()\n          val result = unit.convert(rest, TimeUnit.MILLISECONDS)\n          val diff = rest - TimeUnit.MILLISECONDS.convert(result, unit)\n          val str = result match {\n            case 0    => humanReadable\n            case 1    => humanReadable :+ s\"1 ${name.init}\" // Drop last 's'\n            case more => humanReadable :+ s\"$more $name\"\n          }\n          (str, diff)\n        }\n        ._1\n\n      timeStrings match {\n        case Chain()  => \"0 seconds\"\n        case Chain(a) => a\n        case _ =>\n          val (strings, last) = timeStrings.initLast.get\n          strings.mkString_(\", \") + \" and \" + last\n      }\n    }\n  }\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":21,"column":43},"end":{"line":21,"column":60}},"replacement":"\"\"","id":"176","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":22,"column":43},"end":{"line":22,"column":57}},"replacement":"\"\"","id":"177","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":29,"column":26},"end":{"line":29,"column":37}},"replacement":"\"\"","id":"178","status":"Killed","testsCompleted":31},{"mutatorName":"StringLiteral","location":{"start":{"line":33,"column":29},"end":{"line":33,"column":33}},"replacement":"\"\"","id":"179","status":"Killed","testsCompleted":31},{"mutatorName":"StringLiteral","location":{"start":{"line":33,"column":37},"end":{"line":33,"column":44}},"replacement":"\"\"","id":"180","status":"Killed","testsCompleted":31}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/config/ConfigReader.scala":{"source":"package stryker4jvm.config\n\nimport cats.syntax.either.*\nimport fansi.{Color, Underlined}\nimport pureconfig.error.*\nimport pureconfig.generic.ProductHint\nimport pureconfig.generic.auto.*\nimport pureconfig.{ConfigReader as PureConfigReader, ConfigSource}\nimport stryker4jvm.config.Config.*\nimport stryker4jvm.logging.FansiLogger\n\nimport java.io.FileNotFoundException\n\nobject ConfigReader {\n  // todo: point to stryker4jvm docs when website is adapted\n  private val configDocUrl: String =\n    \"https://stryker-mutator.io/docs/stryker4s/configuration\"\n\n  implicit val hint: ProductHint[Config] = ProductHint[Config](allowUnknownKeys = false)\n\n  def readConfig(\n      confSource: ConfigSource = ConfigSource.file(\"stryker4jvm.conf\")\n  )(implicit log: FansiLogger): Config = {\n    Reader\n      .withoutRecovery[Config](confSource)\n      .recoverWithReader(Failure.onUnknownKey)\n      .recoverWith(Failure.onFileNotFound.andThen(_.asRight[ConfigReaderFailures]))\n      .config\n  }\n\n  def readConfigOfType[T](\n      confSource: ConfigSource = ConfigSource.file(\"stryker4jvm.conf\")\n  )(implicit log: FansiLogger, pureconfig: PureConfigReader[T]): Either[ConfigReaderFailures, T] =\n    Reader.withoutRecovery[T](confSource).tryRead\n\n  /** A configuration on how to attempt to read a config. The reason for its existence is to provide a convenient way to\n    * attempt to read a config with various `PureConfigReader`s, depending on the [[ConfigReaderFailures]] that was\n    * returned from the last attempt. In addition to that, some logging is also enforced during the reading process. If\n    * not for those points, simply using the returned [[Either]] of the [[PureConfigReader]] would be sufficient as\n    * well, since the exposed API here is basically a subset of [[Either]] s.\n    *\n    * @param file\n    *   the [[File]] from which the config is to be read.\n    * @param pureconfig\n    *   [[PureConfigReader]] to read [[T]]\n    * @tparam T\n    *   the type of the config that is to be read.\n    */\n  private class Reader[T] private (\n      configSource: ConfigSource,\n      onFailure: PartialFunction[ConfigReaderFailures, Reader.Result[T]]\n  )(implicit\n      log: FansiLogger,\n      pureconfig: PureConfigReader[T]\n  ) {\n\n    /** Handle certain [[ConfigReaderFailures]] by providing a way to return a [[Reader.Result]] if they occur\n      */\n    def recoverWith(pf: PartialFunction[ConfigReaderFailures, Reader.Result[T]]): Reader[T] =\n      new Reader[T](configSource, this.onFailure orElse pf)\n\n    /** Handle certain [[ConfigReaderFailures]] by providing a different [[PureConfigReader]]\n      */\n    def recoverWithReader(pf: PartialFunction[ConfigReaderFailures, PureConfigReader[T]]): Reader[T] = {\n      def setReader(d: PureConfigReader[T]): Reader.Result[T] = {\n        val api = new Reader[T](configSource, this.onFailure)(log, d)\n        api.tryRead\n      }\n\n      recoverWith(pf.andThen(setReader(_)))\n    }\n\n    /** Force the reading of the config.\n      * @note\n      *   this will throw exceptions when a [[ConfigReaderFailures]] occurs for which no recover-strategy was defined,\n      */\n    def config: T = tryRead.valueOr(Failure.throwException)\n\n    /** Attempt to read a config\n      */\n    def tryRead: Reader.Result[T] = {\n      log.info(s\"Attempting to read config from ${Underlined.On(\"stryker4jvm.conf\")}\")\n      configSource\n        .at(\"stryker4jvm\")\n        .load[T]\n        .recoverWith(onFailure)\n    }\n  }\n\n  private object Reader {\n    type Result[T] = Either[ConfigReaderFailures, T]\n\n    def withoutRecovery[T](\n        configSource: ConfigSource\n    )(implicit log: FansiLogger, d: PureConfigReader[T]): Reader[T] =\n      new Reader[T](configSource, PartialFunction.empty)\n  }\n\n  private object Failure {\n\n    implicit val hint: ProductHint[Config] = ProductHint[Config](allowUnknownKeys = true)\n\n    /** When the config-parsing fails because of an unknown key in the configuration, a [[PureConfigReader]] is provided\n      * that does not fail when unknown keys are present. The names of the unknown keys are logged.\n      */\n    def onUnknownKey(implicit\n        log: FansiLogger\n    ): PartialFunction[ConfigReaderFailures, PureConfigReader[Config]] = {\n      case ConfigReaderFailures(ConvertFailure(UnknownKey(key), _, _), failures*) =>\n        val unknownKeys = key +: failures.collect { case ConvertFailure(UnknownKey(k), _, _) => k }\n\n        log.warn(\n          s\"\"\"The following configuration key(s) are not used, they could stem from an older stryker4jvm version: '${fansi.Str\n              .join(unknownKeys.map(Color.Yellow(_)), \", \")}'.\n             |Please check the documentation at $configDocUrl for available options.\"\"\".stripMargin\n        )\n        implicitly[PureConfigReader[Config]]\n    }\n\n    /** When the config-parsing fails because no file is found at the specified location, a default config is provided.\n      */\n    def onFileNotFound(implicit log: FansiLogger): PartialFunction[ConfigReaderFailures, Config] = {\n      case ConfigReaderFailures(CannotReadFile(fileName, Some(_: FileNotFoundException)), _*) =>\n        log.warn(s\"Could not find config file $fileName\")\n        log.warn(\"Using default config instead...\")\n        log.debug(\"Config used: \" + Config.default)\n\n        Config.default\n    }\n\n    /** Throw a [[ConfigReaderException]] and log the encountered failures.\n      */\n    def throwException[T](failures: ConfigReaderFailures)(implicit log: FansiLogger): Nothing = {\n      log.error(\"Failures in reading config:\")\n      log.error(failures.toList.map(_.description).mkString(System.lineSeparator))\n\n      throw ConfigReaderException[Config](failures)\n    }\n  }\n}\n","mutants":[{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":17,"column":5},"end":{"line":17,"column":62}},"replacement":"\"\"","id":"107","status":"Ignored"},{"mutatorName":"BooleanLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":19,"column":83},"end":{"line":19,"column":88}},"replacement":"true","id":"108","status":"Ignored"},{"mutatorName":"StringLiteral","location":{"start":{"line":22,"column":52},"end":{"line":22,"column":70}},"replacement":"\"\"","id":"109","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":32,"column":52},"end":{"line":32,"column":70}},"replacement":"\"\"","id":"110","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":82,"column":16},"end":{"line":82,"column":86}},"replacement":"\"\"","id":"111","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":82,"column":65},"end":{"line":82,"column":83}},"replacement":"\"\"","id":"112","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":84,"column":13},"end":{"line":84,"column":26}},"replacement":"\"\"","id":"113","status":"Killed","testsCompleted":27},{"mutatorName":"BooleanLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":101,"column":85},"end":{"line":101,"column":89}},"replacement":"false","id":"116","status":"Ignored"},{"mutatorName":"StringLiteral","location":{"start":{"line":113,"column":11},"end":{"line":115,"column":88}},"replacement":"\"\"","id":"131","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":114,"column":55},"end":{"line":114,"column":59}},"replacement":"\"\"","id":"133","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":124,"column":18},"end":{"line":124,"column":57}},"replacement":"\"\"","id":"134","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":125,"column":18},"end":{"line":125,"column":51}},"replacement":"\"\"","id":"136","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":126,"column":19},"end":{"line":126,"column":34}},"replacement":"\"\"","id":"138","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":134,"column":17},"end":{"line":134,"column":46}},"replacement":"\"\"","id":"140","status":"Killed","testsCompleted":27}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/Traverser.scala":{"source":"package stryker4jvm.mutator.scala\n\nimport cats.syntax.flatMap.*\nimport cats.syntax.option.*\nimport stryker4jvm.mutator.scala.extensions.TreeExtensions.{FindExtension, TreeIsInExtension}\nimport stryker4jvm.mutator.scala.extensions.mutationtype.ParentIsTypeLiteral\nimport stryker4jvm.core.logging.Logger\n\nimport scala.meta.*\n\ntrait Traverser {\n\n  /** If the currently visiting node is a node where mutations can be placed, that node is returned, otherwise None\n    */\n  def canPlace(currentTree: Tree): Option[Term]\n\n}\n\nfinal class TraverserImpl(implicit log: Logger) extends Traverser {\n\n  def canPlace(currentTree: Tree): Option[Term] = {\n    val toPlace = currentTree match {\n      case _: Term.Name                                             => none\n      case t: Term.Match                                            => t.some\n      case t: Case if t.cond.flatMap(_.find(currentTree)).isDefined => none\n      case t: Term.Apply                                            => t.some\n      case t: Term.ApplyInfix                                       => t.some\n      case t: Term.Block                                            => t.some\n      case t: Term.If                                               => t.some\n      case t: Term.ForYield                                         => t.some\n      case t: Term.Interpolate                                      => t.some\n      case t: Lit                                                   => t.some\n      case _                                                        => none\n    }\n\n    toPlace\n      // Filter out all the node places that are invalid\n      .filter {\n        case name: Name => !name.isDefinition\n        // Don't place inside `case` patterns or conditions\n        case p\n            if p.findParent[Case].exists(c => c.pat.contains(currentTree) || c.cond.exists(_.contains(currentTree))) =>\n          false\n        case t if t.parent.exists(_.is[Init]) =>\n          false\n        case t if t.parent.exists(p => p.is[Term] && p.isNot[Term.Select]) =>\n          false\n        case ParentIsTypeLiteral() => false\n        case _                     => true\n      }\n      .filterNot(_.isIn[Mod.Annot])\n      .flatTap(t => log.debug(s\"Found tree to place mutations: ${fansi.Color.Green(t.syntax)}\").some)\n\n  }\n}\n","mutants":[{"mutatorName":"MethodExpression","location":{"start":{"line":36,"column":5},"end":{"line":51,"column":36}},"replacement":"toPlace.filter({\n  case name: Name =>\n    !name.isDefinition\n  case p if p.findParent[Case].exists(c => c.pat.contains(currentTree) || c.cond.exists(_.contains(currentTree))) =>\n    false\n  case t if t.parent.exists(_.is[Init]) =>\n    false\n  case t if t.parent.exists(p => p.is[Term] && (p.isNot[Term.Select])) =>\n    false\n  case ParentIsTypeLiteral() =>\n    false\n  case _ =>\n    true\n}).filter(_.isIn[Mod.Annot])","id":"1","status":"Killed","testsCompleted":35},{"mutatorName":"MethodExpression","location":{"start":{"line":36,"column":5},"end":{"line":50,"column":8}},"replacement":"toPlace.filterNot({\n  case name: Name =>\n    !name.isDefinition\n  case p if p.findParent[Case].exists(c => c.pat.contains(currentTree) || c.cond.exists(_.contains(currentTree))) =>\n    false\n  case t if t.parent.exists(_.is[Init]) =>\n    false\n  case t if t.parent.exists(p => p.is[Term] && (p.isNot[Term.Select])) =>\n    false\n  case ParentIsTypeLiteral() =>\n    false\n  case _ =>\n    true\n})","id":"2","status":"Killed","testsCompleted":35},{"mutatorName":"MethodExpression","location":{"start":{"line":42,"column":16},"end":{"line":42,"column":117}},"replacement":"p.findParent[Case].forall(c => c.pat.contains(currentTree) || c.cond.exists(_.contains(currentTree)))","id":"3","status":"Killed","testsCompleted":35},{"mutatorName":"LogicalOperator","location":{"start":{"line":42,"column":75},"end":{"line":42,"column":77}},"replacement":"&&","id":"4","status":"Killed","testsCompleted":40},{"mutatorName":"MethodExpression","location":{"start":{"line":42,"column":78},"end":{"line":42,"column":116}},"replacement":"c.cond.forall(_.contains(currentTree))","id":"5","status":"Survived","testsCompleted":40},{"mutatorName":"BooleanLiteral","location":{"start":{"line":43,"column":11},"end":{"line":43,"column":16}},"replacement":"true","id":"6","status":"Killed","testsCompleted":40},{"mutatorName":"MethodExpression","location":{"start":{"line":44,"column":19},"end":{"line":44,"column":46}},"replacement":"t.parent.forall(_.is[Init])","id":"7","status":"Killed","testsCompleted":35},{"mutatorName":"BooleanLiteral","location":{"start":{"line":45,"column":11},"end":{"line":45,"column":16}},"replacement":"true","id":"8","status":"Survived","testsCompleted":40},{"mutatorName":"MethodExpression","location":{"start":{"line":46,"column":19},"end":{"line":46,"column":75}},"replacement":"t.parent.forall(p => p.is[Term] && (p.isNot[Term.Select]))","id":"9","status":"Killed","testsCompleted":35},{"mutatorName":"LogicalOperator","location":{"start":{"line":46,"column":51},"end":{"line":46,"column":53}},"replacement":"||","id":"10","status":"Killed","testsCompleted":37},{"mutatorName":"BooleanLiteral","location":{"start":{"line":47,"column":11},"end":{"line":47,"column":16}},"replacement":"true","id":"11","status":"Survived","testsCompleted":40},{"mutatorName":"BooleanLiteral","location":{"start":{"line":48,"column":39},"end":{"line":48,"column":44}},"replacement":"true","id":"12","status":"Survived","testsCompleted":40},{"mutatorName":"BooleanLiteral","location":{"start":{"line":49,"column":39},"end":{"line":49,"column":43}},"replacement":"false","id":"13","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":52,"column":31},"end":{"line":52,"column":95}},"replacement":"\"\"","id":"14","status":"Survived","testsCompleted":40}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/MutantMatcher.scala":{"source":"package stryker4jvm.mutator.scala\n\nimport scala.meta.*\n\nimport MutantMatcher.MutationMatcher\nimport stryker4jvm.core.model.CollectedMutants.IgnoredMutation\nimport stryker4jvm.core.model.MutatedCode\nimport stryker4jvm.mutator.scala.PlaceableTree\nimport stryker4jvm.core.model.MutantMetaData\n\nimport cats.syntax.semigroup.*\n\nimport stryker4jvm.mutator.scala.extensions.PartialFunctionOps.*\nimport stryker4jvm.mutator.scala.extensions.TreeExtensions.{IsEqualExtension, PositionExtension, TransformOnceExtension}\n\nimport stryker4jvm.mutator.scala.extensions.mutationtype.*\nimport stryker4jvm.core.model\nimport stryker4jvm.core.config.LanguageMutatorConfig\n\nimport scala.annotation.tailrec\n\ntrait MutantMatcher {\n\n  /** Matches on all types of mutations and returns a list of all the mutations that were found.\n    */\n  def allMatchers: MutationMatcher\n}\n\nobject MutantMatcher {\n\n  /** A PartialFunction that can match on a ScalaMeta tree and return a `Either[IgnoredMutations, Mutations]`.\n    *\n    * If the result is a `Left`, it means a mutant was found, but ignored. The ADT\n    * [[stryker4jvm.core.model.IgnoredMutationReason]] shows the possible reasons.\n    */\n  type MutationMatcher =\n    PartialFunction[Tree, PlaceableTree => Either[Vector[IgnoredMutation[ScalaAST]], Vector[MutatedCode[ScalaAST]]]]\n\n}\n\nclass MutantMatcherImpl(var config: LanguageMutatorConfig) extends MutantMatcher {\n\n  override def allMatchers: MutationMatcher = {\n    matchBooleanLiteral orElse\n      matchEqualityOperator orElse\n      matchLogicalOperator orElse\n      matchConditionalExpression orElse\n      matchMethodExpression orElse\n      matchStringsAndRegex\n  }\n\n  def matchBooleanLiteral: MutationMatcher = {\n    case True(orig)  => createMutations(orig)(False)\n    case False(orig) => createMutations(orig)(True)\n  }\n\n  def matchEqualityOperator: MutationMatcher = {\n    case GreaterThanEqualTo(orig) => createMutations(orig)(GreaterThan, LesserThan, EqualTo)\n    case GreaterThan(orig)        => createMutations(orig)(GreaterThanEqualTo, LesserThan, EqualTo)\n    case LesserThanEqualTo(orig)  => createMutations(orig)(LesserThan, GreaterThanEqualTo, EqualTo)\n    case LesserThan(orig)         => createMutations(orig)(LesserThanEqualTo, GreaterThan, EqualTo)\n    case EqualTo(orig)            => createMutations(orig)(NotEqualTo)\n    case NotEqualTo(orig)         => createMutations(orig)(EqualTo)\n    case TypedEqualTo(orig)       => createMutations(orig)(TypedNotEqualTo)\n    case TypedNotEqualTo(orig)    => createMutations(orig)(TypedEqualTo)\n  }\n\n  def matchLogicalOperator: MutationMatcher = {\n    case And(orig) => createMutations(orig)(Or)\n    case Or(orig)  => createMutations(orig)(And)\n  }\n\n  def matchConditionalExpression: MutationMatcher = {\n    case If(orig)      => createMutations(orig)(ConditionalTrue, ConditionalFalse)\n    case While(orig)   => createMutations(orig)(ConditionalFalse)\n    case DoWhile(orig) => createMutations(orig)(ConditionalFalse)\n  }\n\n  def matchMethodExpression: MutationMatcher = {\n    case Filter(orig, f)      => createMutations(orig, f, FilterNot)\n    case FilterNot(orig, f)   => createMutations(orig, f, Filter)\n    case Exists(orig, f)      => createMutations(orig, f, Forall)\n    case Forall(orig, f)      => createMutations(orig, f, Exists)\n    case Take(orig, f)        => createMutations(orig, f, Drop)\n    case Drop(orig, f)        => createMutations(orig, f, Take)\n    case TakeRight(orig, f)   => createMutations(orig, f, DropRight)\n    case DropRight(orig, f)   => createMutations(orig, f, TakeRight)\n    case TakeWhile(orig, f)   => createMutations(orig, f, DropWhile)\n    case DropWhile(orig, f)   => createMutations(orig, f, TakeWhile)\n    case IsEmpty(orig, f)     => createMutations(orig, f, NonEmpty)\n    case NonEmpty(orig, f)    => createMutations(orig, f, IsEmpty)\n    case IndexOf(orig, f)     => createMutations(orig, f, LastIndexOf)\n    case LastIndexOf(orig, f) => createMutations(orig, f, IndexOf)\n    case Max(orig, f)         => createMutations(orig, f, Min)\n    case Min(orig, f)         => createMutations(orig, f, Max)\n    case MaxBy(orig, f)       => createMutations(orig, f, MinBy)\n    case MinBy(orig, f)       => createMutations(orig, f, MaxBy)\n  }\n\n  def matchStringLiteral: MutationMatcher = {\n    case EmptyString(orig)         => createMutations(orig)(StrykerWasHereString)\n    case NonEmptyString(orig)      => createMutations(orig)(EmptyString)\n    case StringInterpolation(orig) => createMutations(orig)(EmptyString)\n  }\n\n  def matchRegex: MutationMatcher = {\n    case RegexConstructor(orig)   => createMutations(orig, RegexMutations(orig))\n    case RegexStringOps(orig)     => createMutations(orig, RegexMutations(orig))\n    case PatternConstructor(orig) => createMutations(orig, RegexMutations(orig))\n  }\n\n  /** Match both strings and regexes instead of stopping when one of them gives a match\n    */\n  def matchStringsAndRegex: MutationMatcher = matchStringLiteral combine matchRegex\n\n  private def createMutations[T <: Term](\n      original: Term\n  )(\n      firstReplacement: SubstitutionMutation[T],\n      restReplacements: SubstitutionMutation[T]*\n  ): PlaceableTree => Either[Vector[IgnoredMutation[ScalaAST]], Vector[MutatedCode[ScalaAST]]] = {\n    val replacements: Vector[SubstitutionMutation[T]] =\n      Vector(firstReplacement) ++ restReplacements.toVector\n    buildMutations[SubstitutionMutation[T]](original, replacements, _.tree)\n  }\n\n  private def createMutations[T <: Tree](\n      original: Term,\n      f: String => Term,\n      mutated: MethodExpression\n  ): PlaceableTree => Either[Vector[IgnoredMutation[ScalaAST]], Vector[MutatedCode[ScalaAST]]] = {\n    val replacements: Vector[MethodExpression] = Vector(mutated)\n    buildMutations[MethodExpression](original, replacements, _(f))\n  }\n\n  private def createMutations[T <: Term](\n      original: Term,\n      mutated: Either[IgnoredMutation[ScalaAST], Vector[RegularExpression]]\n  ): PlaceableTree => Either[Vector[IgnoredMutation[ScalaAST]], Vector[MutatedCode[ScalaAST]]] = { placeableTree =>\n    import cats.syntax.either.*\n\n    mutated\n      .leftMap(Vector(_))\n      .flatMap(muts => buildMutations[RegularExpression](original, muts, _.tree)(placeableTree))\n  }\n\n  private def buildMutations[T <: Mutation[? <: Tree]](\n      original: Term,\n      replacements: Vector[T],\n      mutationToTerm: T => Term\n  ): PlaceableTree => Either[Vector[IgnoredMutation[ScalaAST]], Vector[MutatedCode[ScalaAST]]] = placeableTree => {\n    val mutations = replacements.map { replacement =>\n      val location: model.elements.Location = replacement match {\n        case r: RegularExpression =>\n          val loc = r.location\n          val start = loc.start\n          val end = loc.end\n\n          new model.elements.Location(\n            new model.elements.Position(start.line, start.column),\n            new model.elements.Position(end.line, end.column)\n          )\n        case _ =>\n          val loc = original.pos.toLocation\n          val start = loc.start\n          val end = loc.end\n\n          new model.elements.Location(\n            new model.elements.Position(start.line, start.column),\n            new model.elements.Position(end.line, end.column)\n          )\n\n      }\n\n      val tree: Tree = mutationToTerm(replacement)\n      val metadata = new MutantMetaData(original.syntax, tree.syntax, replacement.mutationName, location)\n      val mutatedTopStatement = placeableTree.tree\n        .transformExactlyOnce {\n          case t if t.isEqual(original) && t.pos == original.pos =>\n            tree\n        }\n        .getOrElse(\n          throw new RuntimeException(\n            s\"Could not transform '$original' in ${placeableTree.tree} (${metadata.showLocation})\"\n          )\n        )\n\n      mutatedTopStatement match {\n        case t: Term => new MutatedCode(new ScalaAST(value = t), metadata)\n        case t =>\n          throw new RuntimeException(\n            s\"Could not transform '$original' in ${placeableTree.tree} (${metadata.showLocation}). Expected a Term, but was a ${t.getClass().getSimpleName}\"\n          )\n      }\n\n    }\n\n    filterExclusions(mutations, replacements.head, original)\n  }\n\n  private def filterExclusions(\n      mutations: Vector[MutatedCode[ScalaAST]],\n      mutationType: Mutation[?],\n      original: Tree\n  ): Either[Vector[IgnoredMutation[ScalaAST]], Vector[MutatedCode[ScalaAST]]] = {\n    val mutationName = \"stryker4jvm.mutation.\" + mutationType.mutationName\n\n    if (excludedByConfig(mutationType.mutationName) || excludedByAnnotation(original, mutationName))\n      Left(mutations.map(new IgnoredMutation[ScalaAST](_, new model.IgnoredMutationReason.MutationExcluded)))\n    else\n      Right(mutations)\n  }\n\n  private def excludedByConfig(mutation: String): Boolean = config.getExcludedMutations().contains(mutation)\n\n  @tailrec\n  private def excludedByAnnotation(original: Tree, mutationName: String): Boolean = {\n    import stryker4jvm.mutator.scala.extensions.TreeExtensions.*\n    original.parent match {\n      case Some(value) =>\n        value.getMods.exists(isSupressWarningsAnnotation(_, mutationName)) || excludedByAnnotation(\n          value,\n          mutationName\n        )\n      case None => false\n    }\n  }\n\n  private def isSupressWarningsAnnotation(mod: Mod, mutationName: String): Boolean = {\n    mod match {\n      case Mod.Annot(Init(Type.Name(\"SuppressWarnings\"), _, List(List(Term.Apply(Name(\"Array\"), params))))) =>\n        params.exists {\n          case Lit.String(`mutationName`) => true\n          case _                          => false\n        }\n      case _ => false\n    }\n  }\n}\n","mutants":[{"mutatorName":"LogicalOperator","location":{"start":{"line":179,"column":41},"end":{"line":179,"column":43}},"replacement":"||","id":"85","status":"Killed","testsCompleted":74},{"mutatorName":"EqualityOperator","location":{"start":{"line":179,"column":50},"end":{"line":179,"column":52}},"replacement":"!=","id":"86","status":"Killed","testsCompleted":74},{"mutatorName":"StringLiteral","location":{"start":{"line":184,"column":13},"end":{"line":184,"column":99}},"replacement":"\"\"","id":"87","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":192,"column":13},"end":{"line":192,"column":157}},"replacement":"\"\"","id":"88","status":"Survived","testsCompleted":111},{"mutatorName":"StringLiteral","location":{"start":{"line":206,"column":24},"end":{"line":206,"column":47}},"replacement":"\"\"","id":"89","status":"Killed","testsCompleted":74},{"mutatorName":"ConditionalExpression","location":{"start":{"line":208,"column":9},"end":{"line":208,"column":100}},"replacement":"true","id":"90","status":"Killed","testsCompleted":74},{"mutatorName":"ConditionalExpression","location":{"start":{"line":208,"column":9},"end":{"line":208,"column":100}},"replacement":"false","id":"91","status":"Killed","testsCompleted":74},{"mutatorName":"LogicalOperator","location":{"start":{"line":208,"column":53},"end":{"line":208,"column":55}},"replacement":"&&","id":"92","status":"Killed","testsCompleted":74},{"mutatorName":"MethodExpression","location":{"start":{"line":221,"column":9},"end":{"line":221,"column":75}},"replacement":"value.getMods.forall(isSupressWarningsAnnotation(_, mutationName))","id":"93","status":"Killed","testsCompleted":74},{"mutatorName":"LogicalOperator","location":{"start":{"line":221,"column":76},"end":{"line":221,"column":78}},"replacement":"&&","id":"94","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":225,"column":20},"end":{"line":225,"column":25}},"replacement":"true","id":"95","status":"Killed","testsCompleted":74},{"mutatorName":"StringLiteral","location":{"start":{"line":231,"column":37},"end":{"line":231,"column":55}},"replacement":"\"\"","id":"96","status":"Killed","testsCompleted":74},{"mutatorName":"StringLiteral","location":{"start":{"line":231,"column":87},"end":{"line":231,"column":94}},"replacement":"\"\"","id":"97","status":"Killed","testsCompleted":74},{"mutatorName":"MethodExpression","location":{"start":{"line":232,"column":9},"end":{"line":235,"column":10}},"replacement":"params.forall({\n  case Lit.String(`mutationName`) => true\n  case _ => false\n})","id":"98","status":"Survived","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":233,"column":46},"end":{"line":233,"column":50}},"replacement":"false","id":"99","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":234,"column":46},"end":{"line":234,"column":51}},"replacement":"true","id":"100","status":"Survived","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":236,"column":17},"end":{"line":236,"column":22}},"replacement":"true","id":"101","status":"Survived","testsCompleted":74}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/extensions/NumberExtensions.scala":{"source":"package stryker4jvm.extensions\n\nobject NumberExtensions {\n\n  implicit final class RoundDecimalsExtension(val score: Double) extends AnyVal {\n    final def roundDecimals(decimals: Int): Double =\n      if (!score.isNaN())\n        BigDecimal(score).setScale(decimals, BigDecimal.RoundingMode.HALF_UP).toDouble\n      else\n        score\n  }\n\n}\n","mutants":[{"mutatorName":"ConditionalExpression","location":{"start":{"line":7,"column":11},"end":{"line":7,"column":25}},"replacement":"true","id":"174","status":"Killed","testsCompleted":13},{"mutatorName":"ConditionalExpression","location":{"start":{"line":7,"column":11},"end":{"line":7,"column":25}},"replacement":"false","id":"175","status":"Killed","testsCompleted":13}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/config/circe/ConfigEncoder.scala":{"source":"package stryker4jvm.config.circe\n\nimport fs2.io.file.Path\nimport io.circe.Encoder\nimport stryker4jvm.config.{Config, *}\nimport stryker4jvm.core.config.LanguageMutatorConfig\nimport sttp.model.Uri\n\nimport scala.concurrent.duration.FiniteDuration\nimport scala.collection.JavaConverters.asScalaSet\nimport scala.meta.Dialect\n\n/** Circe Encoder for encoding a [[stryker4jvm.config.Config]] to JSON\n  */\ntrait ConfigEncoder {\n  implicit def configEncoder: Encoder[Config] = Encoder\n    .forProduct13(\n      \"mutate\",\n      \"test-filter\",\n      \"base-dir\",\n      \"reporters\",\n      \"files\",\n      \"thresholds\",\n      \"dashboard\",\n      \"timeout\",\n      \"timeout-factor\",\n      \"max-test-runner-reuse\",\n      \"legacy-test-runner\",\n      \"debug\",\n      \"mutator-configs\"\n    )((c: Config) =>\n      (\n        c.mutate,\n        c.testFilter,\n        c.baseDir,\n        c.reporters,\n        c.files,\n        c.thresholds,\n        c.dashboard,\n        c.timeout,\n        c.timeoutFactor,\n        c.maxTestRunnerReuse,\n        c.legacyTestRunner,\n        c.debug,\n        c.mutatorConfigs\n      )\n    )\n    .mapJson(_.deepDropNullValues)\n\n  implicit def pathEncoder: Encoder[Path] = Encoder[String].contramap(_.absolute.toString)\n  implicit def reporterTypeEncoder: Encoder[ReporterType] = Encoder[String].contramap(_.toString.toLowerCase)\n  implicit def thresholdsEncoder: Encoder[Thresholds] =\n    Encoder.forProduct3(\"high\", \"low\", \"break\")(t => (t.high, t.low, t.break))\n\n  implicit def dashboardOptionsEncoder: Encoder[DashboardOptions] = Encoder.forProduct5(\n    \"base-url\",\n    \"report-type\",\n    \"project\",\n    \"version\",\n    \"module\"\n  )(d =>\n    (\n      d.baseUrl,\n      d.reportType,\n      d.project,\n      d.version,\n      d.module\n    )\n  )\n\n  implicit def languageMutatorConfigEncoder: Encoder[LanguageMutatorConfig] = Encoder.forProduct2(\n    \"dialect\",\n    \"excluded-mutations\"\n  )(c =>\n    (\n      c.getDialect,\n      asScalaSet(c.getExcludedMutations)\n    )\n  )\n\n  implicit def finiteDurationEncoder: Encoder[FiniteDuration] = Encoder[Long].contramap(_.toMillis)\n\n  implicit def uriEncoder: Encoder[Uri] = Encoder[String].contramap(_.toString())\n\n  implicit def reportTypeEncoder: Encoder[DashboardReportType] = Encoder[String].contramap(_.toString.toLowerCase)\n\n  implicit def dialectEncoder: Encoder[Dialect] = Encoder[String].contramap(_.toString.toLowerCase)\n\n  implicit def debugOptionsEncoder: Encoder[DebugOptions] =\n    Encoder.forProduct2(\"log-test-runner-stdout\", \"debug-test-runner\")(d => (d.logTestRunnerStdout, d.debugTestRunner))\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":18,"column":7},"end":{"line":18,"column":15}},"replacement":"\"\"","id":"206","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":19,"column":7},"end":{"line":19,"column":20}},"replacement":"\"\"","id":"207","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":20,"column":7},"end":{"line":20,"column":17}},"replacement":"\"\"","id":"208","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":21,"column":7},"end":{"line":21,"column":18}},"replacement":"\"\"","id":"209","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":22,"column":7},"end":{"line":22,"column":14}},"replacement":"\"\"","id":"210","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":23,"column":7},"end":{"line":23,"column":19}},"replacement":"\"\"","id":"211","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":24,"column":7},"end":{"line":24,"column":18}},"replacement":"\"\"","id":"212","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":25,"column":7},"end":{"line":25,"column":16}},"replacement":"\"\"","id":"213","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":26,"column":7},"end":{"line":26,"column":23}},"replacement":"\"\"","id":"214","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":27,"column":7},"end":{"line":27,"column":30}},"replacement":"\"\"","id":"215","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":28,"column":7},"end":{"line":28,"column":27}},"replacement":"\"\"","id":"216","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":29,"column":7},"end":{"line":29,"column":14}},"replacement":"\"\"","id":"217","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":30,"column":7},"end":{"line":30,"column":24}},"replacement":"\"\"","id":"218","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":53,"column":25},"end":{"line":53,"column":31}},"replacement":"\"\"","id":"219","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":53,"column":33},"end":{"line":53,"column":38}},"replacement":"\"\"","id":"220","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":53,"column":40},"end":{"line":53,"column":47}},"replacement":"\"\"","id":"221","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":56,"column":5},"end":{"line":56,"column":15}},"replacement":"\"\"","id":"222","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":57,"column":5},"end":{"line":57,"column":18}},"replacement":"\"\"","id":"223","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":58,"column":5},"end":{"line":58,"column":14}},"replacement":"\"\"","id":"224","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":59,"column":5},"end":{"line":59,"column":14}},"replacement":"\"\"","id":"225","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":60,"column":5},"end":{"line":60,"column":13}},"replacement":"\"\"","id":"226","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":72,"column":5},"end":{"line":72,"column":14}},"replacement":"\"\"","id":"227","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":73,"column":5},"end":{"line":73,"column":25}},"replacement":"\"\"","id":"228","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":90,"column":25},"end":{"line":90,"column":49}},"replacement":"\"\"","id":"229","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":90,"column":51},"end":{"line":90,"column":70}},"replacement":"\"\"","id":"230","status":"Killed","testsCompleted":13}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/extensions/mutationtype/RegexMutator.scala":{"source":"package stryker4jvm.mutator.scala.extensions.mutationtype\n\nimport cats.data.NonEmptyVector\nimport cats.syntax.either.*\nimport mutationtesting.Location\nimport stryker4jvm.mutator.scala.extensions.TreeExtensions.{\n  LocationExtension,\n  PositionExtension,\n  RegexLocationExtension\n}\nimport stryker4jvm.core.model.{MutantMetaData, MutatedCode}\nimport stryker4jvm.mutator.scala.extensions.RegexParseError\n// import stryker4jvm.mutator.scala.mutants.IgnoredMutation\n\nimport stryker4jvm.core.model.CollectedMutants.IgnoredMutation\n\nimport scala.meta.*\nimport stryker4jvm.mutator.scala.ScalaAST\n\n/** Matches on `new scala.util.matching.Regex(\"[a-z]\", _*)`\n  */\ncase object RegexConstructor {\n  // Two parents up is the full constructor\n  def unapply(arg: Lit.String): Option[Lit.String] = arg.parent\n    .flatMap(_.parent)\n    .collect {\n      case Term.New(Init(Type.Name(\"Regex\"), _, exprss))           => exprss\n      case Term.New(Init(t\"scala.util.matching.Regex\", _, exprss)) => exprss\n    }\n    .collect { case (`arg` :: _) :: _ => arg }\n}\n\n/** Matches on `\"[a-z]\".r`\n  */\ncase object RegexStringOps {\n\n  def unapply(arg: Lit.String): Option[Lit.String] = arg.parent\n    .collect { case Term.Select(`arg`, Term.Name(\"r\")) => arg }\n\n}\n\n/** Matches on `Pattern.compile(\"[a-z]\", _*)`\n  */\ncase object PatternConstructor {\n  def unapply(arg: Lit.String): Option[Lit.String] = arg.parent.collect {\n    case Term.Apply(q\"Pattern.compile\", `arg` :: _)                 => arg\n    case Term.Apply(q\"java.util.regex.Pattern.compile\", `arg` :: _) => arg\n  }\n}\n\nobject RegexMutations {\n  def apply(lit: Lit.String): Either[IgnoredMutation[ScalaAST], Vector[RegularExpression]] = {\n    weaponregex.WeaponRegeX\n      .mutate(lit.value, mutationLevels = Seq(1))\n      .leftMap(ignoredMutation(lit, _))\n      .map(_.toVector)\n      .map(\n        NonEmptyVector\n          .fromVectorUnsafe(_)\n          .map(r => RegularExpression(r.pattern, r.location.toLocation(offset = lit.pos.toLocation)))\n          .toVector\n      )\n  }\n\n  private def ignoredMutation(lit: Lit.String, e: String) = {\n    val mutatedCode =\n      new MutatedCode(\n        new ScalaAST(value = lit.asInstanceOf[Term]),\n        new MutantMetaData(lit.value, \"\", \"RegularExpression\", lit.pos.toLocation.asJvmCore)\n      )\n\n    new IgnoredMutation[ScalaAST](mutatedCode, RegexParseError(lit.value, e))\n  }\n\n}\n\nfinal case class RegularExpression(pattern: String, location: Location) extends SubstitutionMutation[Lit.String] {\n\n  def mutationName: String = classOf[RegularExpression].getSimpleName\n\n  override def tree: Lit.String = Lit.String(pattern)\n\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":27,"column":36},"end":{"line":27,"column":43}},"replacement":"\"\"","id":"183","status":"Killed","testsCompleted":74},{"mutatorName":"StringLiteral","location":{"start":{"line":38,"column":50},"end":{"line":38,"column":53}},"replacement":"\"\"","id":"184","status":"Killed","testsCompleted":74},{"mutatorName":"StringLiteral","location":{"start":{"line":69,"column":39},"end":{"line":69,"column":41}},"replacement":"\"Stryker was here!\"","id":"185","status":"Survived","testsCompleted":74},{"mutatorName":"StringLiteral","location":{"start":{"line":69,"column":43},"end":{"line":69,"column":62}},"replacement":"\"\"","id":"187","status":"Survived","testsCompleted":74}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/extensions/mutationtype/LogicalOperator.scala":{"source":"package stryker4jvm.mutator.scala.extensions.mutationtype\n\nimport scala.meta.Term\n\ncase object And extends LogicalOperator {\n  override val tree: Term.Name = Term.Name(\"&&\")\n}\n\ncase object Or extends LogicalOperator {\n  override val tree: Term.Name = Term.Name(\"||\")\n}\n","mutants":[{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":6,"column":44},"end":{"line":6,"column":48}},"replacement":"\"\"","id":"173","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":10,"column":44},"end":{"line":10,"column":48}},"replacement":"\"\"","id":"174","status":"Ignored"}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/run/process/WindowsProcessRunner.scala":{"source":"package stryker4jvm.run.process\n\nimport cats.effect.IO\nimport fs2.io.file.Path\nimport stryker4jvm.config.Config\nimport stryker4jvm.logging.FansiLogger\n\nimport scala.util.Try\n\nclass WindowsProcessRunner(implicit log: FansiLogger) extends ProcessRunner {\n  override def apply(command: Command, workingDir: Path): Try[Seq[String]] =\n    super.apply(Command(s\"cmd /c ${command.command}\", command.args), workingDir)\n\n  override def apply(command: Command, workingDir: Path, envVar: (String, String)*)(implicit\n      config: Config\n  ): IO[Try[Int]] = super.apply(Command(s\"cmd /c ${command.command}\", command.args), workingDir, envVar*)\n\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":12,"column":25},"end":{"line":12,"column":53}},"replacement":"\"\"","id":"195","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":16,"column":41},"end":{"line":16,"column":69}},"replacement":"\"\"","id":"196","status":"NoCoverage"}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/reporting/dashboard/DashboardConfigProvider.scala":{"source":"package stryker4jvm.reporting.dashboard\n\nimport cats.data.ValidatedNec\nimport cats.syntax.apply.*\nimport cats.syntax.option.*\nimport stryker4jvm.config.Config\nimport stryker4jvm.env.Environment\nimport stryker4jvm.reporting.dashboard.Providers.*\nimport stryker4jvm.reporting.model.DashboardConfig\n\nclass DashboardConfigProvider(env: Environment)(implicit config: Config) {\n  def resolveConfig(): ValidatedNec[String, DashboardConfig] =\n    (resolveapiKey(), resolveproject(), resolveversion()).mapN {\n      DashboardConfig(\n        _,\n        config.dashboard.baseUrl,\n        config.dashboard.reportType,\n        _,\n        _,\n        config.dashboard.module\n      )\n    }\n\n  private val apiKeyName = \"STRYKER_DASHBOARD_API_KEY\"\n  private def resolveapiKey() =\n    env\n      .get(apiKeyName)\n      .toValidNec(apiKeyName)\n\n  private def resolveproject() =\n    config.dashboard.project\n      .orElse(byCiProvider(_.determineProject()))\n      .toValidNec(\"dashboard.project\")\n\n  private def resolveversion() =\n    config.dashboard.version\n      .orElse(byCiProvider(_.determineVersion()))\n      .toValidNec(\"dashboard.version\")\n\n  private def byCiProvider[T](f: CiProvider => Option[T]) = Providers.determineCiProvider(env).flatMap(f)\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":24,"column":28},"end":{"line":24,"column":55}},"replacement":"\"\"","id":"365","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":33,"column":19},"end":{"line":33,"column":38}},"replacement":"\"\"","id":"366","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":38,"column":19},"end":{"line":38,"column":38}},"replacement":"\"\"","id":"367","status":"Killed","testsCompleted":12}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/config/Config.scala":{"source":"package stryker4jvm.config\n\nimport fs2.io.file.Path\nimport stryker4jvm.core.config.LanguageMutatorConfig\n\nimport java.util\nimport java.util.concurrent.TimeUnit\nimport scala.concurrent.duration.FiniteDuration\nimport scala.meta.{dialects, Dialect}\n\nfinal case class Config(\n    mutate: Seq[String] = Seq.empty,\n    testFilter: Seq[String] = Seq.empty,\n    baseDir: Path = Path(\"\").absolute,\n    reporters: Set[ReporterType] = Set(Console, Html),\n    files: Seq[String] = Seq.empty,\n    thresholds: Thresholds = Thresholds(),\n    dashboard: DashboardOptions = DashboardOptions(),\n    timeout: FiniteDuration = FiniteDuration(5000, TimeUnit.MILLISECONDS),\n    timeoutFactor: Double = 1.5,\n    maxTestRunnerReuse: Option[Int] = None,\n    legacyTestRunner: Boolean = false,\n    concurrency: Int = Config.defaultConcurrency,\n    debug: DebugOptions = DebugOptions(),\n    staticTmpDir: Boolean = false,\n    cleanTmpDir: Boolean = true,\n    mutatorConfigs: Map[String, LanguageMutatorConfig] = Map(\n      \".scala\" -> new LanguageMutatorConfig(\"2_13\", new util.HashSet[String]())\n    )\n)\n\nobject Config extends pure.ConfigConfigReader with circe.ConfigEncoder {\n\n  private def defaultConcurrency: Int = concurrencyFor(Runtime.getRuntime().availableProcessors())\n\n  def concurrencyFor(cpuCoreCount: Int): Int = {\n    // Use (n / 4 concurrency, rounded) + 1\n    if (cpuCoreCount > 4) cpuCoreCount / 2\n    else cpuCoreCount\n    (cpuCoreCount.toDouble / 4).round.toInt + 1\n  }\n\n  /** Type alias for `Set[String]` so extra validation can be done\n    */\n  type ExcludedMutations = Set[String]\n\n  lazy val default: Config = Config()\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":14,"column":26},"end":{"line":14,"column":28}},"replacement":"\"Stryker was here!\"","id":"30","status":"Survived","testsCompleted":57},{"mutatorName":"BooleanLiteral","location":{"start":{"line":22,"column":33},"end":{"line":22,"column":38}},"replacement":"true","id":"34","status":"Survived","testsCompleted":57},{"mutatorName":"BooleanLiteral","location":{"start":{"line":25,"column":29},"end":{"line":25,"column":34}},"replacement":"true","id":"36","status":"Survived","testsCompleted":57},{"mutatorName":"BooleanLiteral","location":{"start":{"line":26,"column":28},"end":{"line":26,"column":32}},"replacement":"false","id":"37","status":"Survived","testsCompleted":57},{"mutatorName":"StringLiteral","location":{"start":{"line":28,"column":7},"end":{"line":28,"column":15}},"replacement":"\"\"","id":"38","status":"Survived","testsCompleted":57},{"mutatorName":"StringLiteral","location":{"start":{"line":28,"column":45},"end":{"line":28,"column":51}},"replacement":"\"\"","id":"39","status":"Survived","testsCompleted":57},{"mutatorName":"ConditionalExpression","location":{"start":{"line":38,"column":9},"end":{"line":38,"column":25}},"replacement":"true","id":"40","status":"Survived","testsCompleted":70},{"mutatorName":"ConditionalExpression","location":{"start":{"line":38,"column":9},"end":{"line":38,"column":25}},"replacement":"false","id":"41","status":"Survived","testsCompleted":70},{"mutatorName":"EqualityOperator","location":{"start":{"line":38,"column":22},"end":{"line":38,"column":23}},"replacement":">=","id":"42","status":"Survived","testsCompleted":70},{"mutatorName":"EqualityOperator","location":{"start":{"line":38,"column":22},"end":{"line":38,"column":23}},"replacement":"<","id":"43","status":"Survived","testsCompleted":70},{"mutatorName":"EqualityOperator","location":{"start":{"line":38,"column":22},"end":{"line":38,"column":23}},"replacement":"==","id":"44","status":"Survived","testsCompleted":70}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/Stryker4jvm.scala":{"source":"package stryker4jvm\n\nimport cats.effect.IO\nimport cats.implicits.toAlignOps\nimport cats.syntax.align\nimport mutationtesting.{Metrics, MetricsResult}\nimport stryker4jvm.config.Config\nimport stryker4jvm.files.MutatesFileResolver\nimport stryker4jvm.model.{MutantResultsPerFile, RunResult}\nimport stryker4jvm.mutants.Mutator\nimport stryker4jvm.reporting.{FinishedRunEvent, IOReporter}\nimport stryker4jvm.reporting.mapper.MutantRunResultMapper\nimport stryker4jvm.run.MutantRunner\nimport stryker4jvm.run.threshold.{ScoreStatus, ThresholdChecker}\n\nclass Stryker4jvm(\n    fileSource: MutatesFileResolver,\n    mutator: Mutator,\n    runner: MutantRunner,\n    reporter: IOReporter\n)(implicit\n    config: Config\n) {\n\n  def run(): IO[ScoreStatus] = {\n    val filesToMutate = fileSource.files\n    for {\n      (ignored, files) <- mutator.go(filesToMutate)\n      result <- runner(files)\n      metrics <- createAndReportResults(result, ignored)\n      scoreStatus = ThresholdChecker.determineScoreStatus(metrics.mutationScore)\n    } yield scoreStatus\n  }\n\n  // TODO: move\n  def createAndReportResults(results: RunResult, ignored: MutantResultsPerFile): IO[MetricsResult] = {\n    val merged = results.results.alignCombine(ignored)\n    val mapper = new MutantRunResultMapper() {}\n    for {\n      time <- IO.realTime\n      report = mapper.toReport(merged)\n      metrics = Metrics.calculateMetrics(report)\n      reportsLocation = config.baseDir / \"target/stryker4jvm-report\" / time.toMillis.toString\n      _ <- reporter.onRunFinished(FinishedRunEvent(report, metrics, results.duration, reportsLocation.toNioPath))\n    } yield metrics\n  }\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":43,"column":42},"end":{"line":43,"column":69}},"replacement":"\"\"","id":"0","status":"Survived","testsCompleted":1}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/run/Stryker4jvmRunner.scala":{"source":"package stryker4jvm.run\n\nimport cats.data.NonEmptyList\nimport cats.effect.{IO, Resource}\nimport fs2.io.file.Path\nimport stryker4jvm.Stryker4jvm\nimport stryker4jvm.config.{Config, ConfigReader, Console, Dashboard, Html, Json}\nimport stryker4jvm.core.model.InstrumenterOptions\nimport stryker4jvm.extensions.Stryker4jvmCoreConversions.*\nimport stryker4jvm.files.{ConfigFilesResolver, DiskFileIO, FilesFileResolver, GlobFileResolver, MutatesFileResolver}\nimport stryker4jvm.logging.{FansiLogger, SttpLogWrapper}\nimport stryker4jvm.model.CompilerErrMsg\nimport stryker4jvm.mutants.{Mutator, SupportedLanguageMutators}\nimport stryker4jvm.reporting.*\nimport stryker4jvm.reporting.dashboard.DashboardConfigProvider\nimport stryker4jvm.reporting.reporters.*\nimport stryker4jvm.run.process.ProcessRunner\nimport stryker4jvm.run.threshold.ScoreStatus\nimport sttp.client3.SttpBackend\nimport sttp.client3.httpclient.fs2.HttpClientFs2Backend\nimport sttp.client3.logging.LoggingBackend\nimport sttp.model.HeaderNames\n\nabstract class Stryker4jvmRunner(implicit log: FansiLogger) {\n  def run(): IO[ScoreStatus] = {\n    implicit val config: Config = ConfigReader.readConfig()\n\n    val createTestRunnerPool = (path: Path) => resolveTestRunners(path).map(ResourcePool(_))\n    val reporter = new AggregateReporter(resolveReporters())\n\n    val stryker4jvm = new Stryker4jvm(\n      resolveMutatesFileSource,\n      new Mutator(\n        SupportedLanguageMutators.supportedMutators(config.mutatorConfigs, log, instrumenterOptions)\n      ),\n      new MutantRunner(createTestRunnerPool, resolveFilesFileSource, new RollbackHandler(), reporter),\n      reporter\n    )\n\n    stryker4jvm.run()\n  }\n\n  def resolveReporters()(implicit config: Config): List[IOReporter] =\n    config.reporters.toList.map {\n      case Console => new ConsoleReporter()\n      case Html    => new HtmlReporter(new DiskFileIO())\n      case Json    => new JsonReporter(new DiskFileIO())\n      case Dashboard =>\n        implicit val httpBackend: Resource[IO, SttpBackend[IO, Any]] =\n          // Catch if the user runs the dashboard on Java <11\n          try\n            HttpClientFs2Backend\n              .resource[IO]()\n              .map(\n                LoggingBackend(\n                  _,\n                  new SttpLogWrapper(),\n                  logResponseBody = true,\n                  sensitiveHeaders = HeaderNames.SensitiveHeaders + \"X-Api-Key\"\n                )\n              )\n          catch {\n            case e: BootstrapMethodError =>\n              // Wrap in a UnsupportedOperationException because BootstrapMethodError will not be caught\n              Resource.raiseError[IO, Nothing, Throwable](\n                new UnsupportedOperationException(\n                  \"Could not send results to dashboard. The dashboard reporter only supports JDK 11 or above. If you are running on a lower Java version please upgrade or disable the dashboard reporter.\",\n                  e\n                )\n              )\n          }\n        new DashboardReporter(new DashboardConfigProvider(sys.env))\n    }\n\n  def resolveTestRunners(tmpDir: Path)(implicit\n      config: Config\n  ): Either[NonEmptyList[CompilerErrMsg], NonEmptyList[Resource[IO, stryker4jvm.run.TestRunner]]]\n\n  def resolveMutatesFileSource(implicit config: Config): MutatesFileResolver =\n    new GlobFileResolver(\n      config.baseDir,\n      if (config.mutate.nonEmpty) config.mutate else SupportedLanguageMutators.mutatesFileSources\n    )\n\n  def resolveFilesFileSource(implicit config: Config): FilesFileResolver = new ConfigFilesResolver(ProcessRunner())\n\n  def instrumenterOptions(implicit config: Config): InstrumenterOptions\n}\n","mutants":[{"mutatorName":"BooleanLiteral","location":{"start":{"line":58,"column":37},"end":{"line":58,"column":41}},"replacement":"false","id":"12","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":59,"column":69},"end":{"line":59,"column":80}},"replacement":"\"\"","id":"13","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":67,"column":19},"end":{"line":67,"column":204}},"replacement":"\"\"","id":"14","status":"NoCoverage"},{"mutatorName":"ConditionalExpression","location":{"start":{"line":82,"column":11},"end":{"line":82,"column":33}},"replacement":"true","id":"15","status":"NoCoverage"},{"mutatorName":"ConditionalExpression","location":{"start":{"line":82,"column":11},"end":{"line":82,"column":33}},"replacement":"false","id":"16","status":"NoCoverage"},{"mutatorName":"MethodExpression","location":{"start":{"line":82,"column":11},"end":{"line":82,"column":33}},"replacement":"config.mutate.isEmpty","id":"18","status":"NoCoverage"}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/reporting/reporters/AggregateReporter.scala":{"source":"package stryker4jvm.reporting.reporters\n\nimport cats.effect.IO\nimport cats.syntax.parallel.*\nimport fs2.Pipe\nimport stryker4jvm.config.Config\nimport stryker4jvm.logging.FansiLogger\nimport stryker4jvm.reporting.{FinishedRunEvent, IOReporter}\n\nclass AggregateReporter(reporters: List[IOReporter])(implicit log: FansiLogger) extends IOReporter {\n\n  override def mutantTested =\n    reportAll(_.mutantTested)\n\n  override def onRunFinished(runReport: FinishedRunEvent): IO[Unit] =\n    reporters.parTraverse_(_.onRunFinished(runReport))\n\n  /** Broadcast to all reporters in parallel\n    */\n  private def reportAll[T](toReporterPipe: IOReporter => Pipe[IO, T, Nothing]): Pipe[IO, T, Nothing] = {\n    val pipes = reporters.map(toReporterPipe)\n    if (pipes.isEmpty) _.drain\n    else\n      _.broadcastThrough(reporters.map(toReporterPipe)*).attempt\n        .collect { case Left(f) => f }\n        .evalMap { e =>\n          IO(log.error(s\"Reporter failed to report\", e))\n        }\n        .drain\n  }\n}\n","mutants":[{"mutatorName":"ConditionalExpression","location":{"start":{"line":22,"column":9},"end":{"line":22,"column":22}},"replacement":"true","id":"298","status":"Killed","testsCompleted":3},{"mutatorName":"ConditionalExpression","location":{"start":{"line":22,"column":9},"end":{"line":22,"column":22}},"replacement":"false","id":"299","status":"Killed","testsCompleted":3},{"mutatorName":"MethodExpression","location":{"start":{"line":22,"column":9},"end":{"line":22,"column":22}},"replacement":"pipes.nonEmpty","id":"300","status":"Killed","testsCompleted":3},{"mutatorName":"StringLiteral","location":{"start":{"line":27,"column":24},"end":{"line":27,"column":52}},"replacement":"\"\"","id":"301","status":"Killed","testsCompleted":3}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/exception/InvalidFileTypeException.scala":{"source":"package stryker4jvm.exception\n\nimport fs2.io.file.Path\nimport stryker4jvm.core.exception.Stryker4jvmException\n\nfinal case class InvalidFileTypeException(path: Path)\n    extends Stryker4jvmException(\n      s\"File $path with extension ${path.extName} does not have a supported Language Mutator.\"\n    )\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":8,"column":7},"end":{"line":8,"column":95}},"replacement":"\"\"","id":"4","status":"Survived","testsCompleted":7}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/reporting/mapper/MutantRunResultMapper.scala":{"source":"package stryker4jvm.reporting.mapper\n\nimport cats.syntax.option.*\nimport fs2.io.file.Path\nimport mutationtesting.*\nimport stryker4jvm.config.{Config, Thresholds as ConfigThresholds}\nimport stryker4jvm.model.MutantResultsPerFile\nimport stryker4jvm.extensions.FileExtensions.PathExtensions\n\nimport java.nio.file.Files\nimport scala.util.Try\n\ntrait MutantRunResultMapper {\n  protected[stryker4jvm] def toReport(\n      results: MutantResultsPerFile\n  )(implicit config: Config): MutationTestResult[Config] =\n    MutationTestResult(\n      thresholds = toThresholds(config.thresholds),\n      files = toFileResultMap(results),\n      projectRoot = config.baseDir.absolute.toString.some,\n      config = config.some,\n      system = systemInformation.some,\n      framework = frameworkInformation.some\n    )\n\n  private def toThresholds(thresholds: ConfigThresholds): Thresholds =\n    Thresholds(high = thresholds.high, low = thresholds.low)\n\n  private def toFileResultMap(\n      results: MutantResultsPerFile\n  )(implicit config: Config): Map[String, FileResult] =\n    results.map { case (path, runResults) =>\n      path.relativePath.toString.replace('\\\\', '/') -> FileResult(fileContentAsString(path), runResults)\n    }\n\n  private def fileContentAsString(path: Path)(implicit config: Config): String =\n    new String(Files.readAllBytes((if (path.isAbsolute) path else config.baseDir / path).toNioPath))\n\n  private def systemInformation: SystemInformation = SystemInformation(\n    ci = sys.env.contains(\"CI\"),\n    os = OSInformation(platform = sys.props(\"os.name\"), version = sys.props(\"os.version\").some).some,\n    cpu = CpuInformation(logicalCores = Runtime.getRuntime.availableProcessors()).some,\n    // Should be in MB\n    ram = RamInformation(total = Runtime.getRuntime.totalMemory() / 1024 / 1024).some\n  )\n\n  private def frameworkInformation: FrameworkInformation = {\n    val stryker4jvmVersion = Try(this.getClass.getPackage.getImplementationVersion).toOption\n      .flatMap(Option(_)) // null if not packaged\n\n    FrameworkInformation(\n      name = \"stryker4jvm\",\n      version = stryker4jvmVersion,\n      branding = brandingInformation.some\n    )\n  }\n\n  private def brandingInformation: BrandingInformation =\n    BrandingInformation(\n      homepageUrl = \"https://stryker-mutator.io\",\n      imageUrl =\n        \"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' stroke-linejoin='round' stroke-miterlimit='2' clip-rule='evenodd' viewBox='0 0 1458 1458'%3E%3Cpath fill='none' d='M0 0h1458v1458H0z'/%3E%3CclipPath id='a'%3E%3Cpath d='M0 0h1458v1458H0z'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23a)'%3E%3Cpath fill='%23e74c3c' fill-rule='nonzero' d='M1458 729c0 402.7-326.3 729-729 729S0 1131.7 0 729a729 729 0 0 1 1458 0'/%3E%3Cpath fill-opacity='.3' d='m778.3 1456.2-201.7-201.8 233-105 85-78.7v-64.3l-257-257-44-187-50-208 251.8-82.8 281.2 117.8 380.1 379.2A729 729 0 0 1 778.3 1456z'/%3E%3Cpath fill='%23f1c40f' fill-rule='nonzero' d='M753.4 329.5c41.8 0 74.6 7.8 98 25.4 23.5 18 41.6 44 55 77.1l11.8 28.7 165.7-58.2-14.2-32a343.2 343.2 0 0 0-114.1-144.1C906.2 191 838 172.1 750.7 172.1c-50.8 0-95.6 7.4-134.8 21.5-40 14.7-74 34.8-102.2 60.3a257.7 257.7 0 0 0-65.5 92.7A287.4 287.4 0 0 0 426.1 459c0 72.5 20.7 133.3 61.2 182.7 38.6 47.3 98.3 88 179.8 121.3 42.3 17.5 78.7 33.1 109.3 47a247 247 0 0 1 66.1 41.7 129.5 129.5 0 0 1 33.6 49.3c7.8 20.2 11.2 45.7 11.2 76.4 0 28-4.3 51.8-13.6 71.2a119.9 119.9 0 0 1-34.5 44.2 139.4 139.4 0 0 1-49.4 24.5 222 222 0 0 1-58.7 8c-29.4 0-54.4-3.4-75.2-10.8-20-7-37.1-16-51.2-27.4a147 147 0 0 1-33.8-38.3 253 253 0 0 1-23-48.4l-11-31.4-161.7 60.6 10.8 30.1a370.5 370.5 0 0 0 42 82.8 303 303 0 0 0 69.6 72.7 342 342 0 0 0 99.4 51c37.8 12.7 82 19.2 132.6 19.2 50 0 95.8-8.3 137.6-24.6 42.2-16.5 78.4-39 108.8-67.3a307 307 0 0 0 71.9-100.7 296.5 296.5 0 0 0 25.9-122.2c0-54.3-8.4-100.4-24.2-138.3a298 298 0 0 0-66-98.8 385.3 385.3 0 0 0-93.8-67.2 1108.6 1108.6 0 0 0-106.6-47.5 745.9 745.9 0 0 1-90-39.6 239 239 0 0 1-53.5-37.3 97.4 97.4 0 0 1-24.7-37.6c-5.4-15.5-8-33.4-8-53.6 0-40.9 11.3-71.5 37-90.5 28.5-20.9 65-30.7 109.4-30.7z'/%3E%3Cpath d='M720 0h18v113h-18zm738 738v-18h-113v18h113zm-738 607h18v113h-18zM113 738v-18H0v18h113z'/%3E%3C/g%3E%3C/svg%3E\".some\n    )\n}\n","mutants":[{"mutatorName":"ConditionalExpression","location":{"start":{"line":37,"column":40},"end":{"line":37,"column":55}},"replacement":"true","id":"368","status":"Survived","testsCompleted":1},{"mutatorName":"ConditionalExpression","location":{"start":{"line":37,"column":40},"end":{"line":37,"column":55}},"replacement":"false","id":"369","status":"Killed","testsCompleted":1},{"mutatorName":"StringLiteral","location":{"start":{"line":40,"column":27},"end":{"line":40,"column":31}},"replacement":"\"\"","id":"370","status":"Survived","testsCompleted":1},{"mutatorName":"StringLiteral","location":{"start":{"line":41,"column":45},"end":{"line":41,"column":54}},"replacement":"\"\"","id":"371","status":"Killed","testsCompleted":1},{"mutatorName":"StringLiteral","location":{"start":{"line":41,"column":77},"end":{"line":41,"column":89}},"replacement":"\"\"","id":"372","status":"Killed","testsCompleted":1},{"mutatorName":"StringLiteral","location":{"start":{"line":52,"column":14},"end":{"line":52,"column":27}},"replacement":"\"\"","id":"381","status":"Survived","testsCompleted":1},{"mutatorName":"StringLiteral","location":{"start":{"line":60,"column":21},"end":{"line":60,"column":49}},"replacement":"\"\"","id":"383","status":"Survived","testsCompleted":1},{"mutatorName":"StringLiteral","location":{"start":{"line":62,"column":9},"end":{"line":62,"column":1920}},"replacement":"\"\"","id":"384","status":"Survived","testsCompleted":1}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/run/process/ProcessRunner.scala":{"source":"package stryker4jvm.run.process\n\nimport cats.effect.IO\nimport fs2.io.file.Path\nimport stryker4jvm.config.Config\nimport stryker4jvm.logging.FansiLogger\n\nimport scala.sys.process.{Process, ProcessLogger}\nimport scala.util.Try\n\nabstract class ProcessRunner(implicit log: FansiLogger) {\n  def apply(command: Command, workingDir: Path): Try[Seq[String]] = {\n    Try {\n      Process(s\"${command.command} ${command.args}\", workingDir.toNioPath.toFile())\n        .!!<(ProcessLogger(log.debug(_)))\n        .linesIterator\n        .toSeq\n    }\n  }\n\n  def apply(command: Command, workingDir: Path, envVar: (String, String)*)(implicit config: Config): IO[Try[Int]] = {\n    val logger: String => Unit =\n      if (config.debug.logTestRunnerStdout) m => log.debug(s\"testrunner: $m\")\n      else _ => ()\n\n    ProcessResource\n      .fromProcessBuilder(\n        Process(s\"${command.command} ${command.args}\", workingDir.toNioPath.toFile(), envVar*)\n      )(logger)\n      .use(p => IO.blocking(p.exitValue()))\n      .attempt\n      .map(_.toTry)\n  }\n}\n\nobject ProcessRunner {\n  private def isWindows: Boolean = sys.props(\"os.name\").toLowerCase.contains(\"windows\")\n\n  def apply()(implicit log: FansiLogger): ProcessRunner = {\n    if (isWindows) new WindowsProcessRunner\n    else new UnixProcessRunner\n  }\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":14,"column":15},"end":{"line":14,"column":52}},"replacement":"\"\"","id":"197","status":"Killed","testsCompleted":1},{"mutatorName":"ConditionalExpression","location":{"start":{"line":23,"column":11},"end":{"line":23,"column":43}},"replacement":"true","id":"198","status":"NoCoverage"},{"mutatorName":"ConditionalExpression","location":{"start":{"line":23,"column":11},"end":{"line":23,"column":43}},"replacement":"false","id":"199","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":23,"column":60},"end":{"line":23,"column":77}},"replacement":"\"\"","id":"200","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":28,"column":17},"end":{"line":28,"column":54}},"replacement":"\"\"","id":"201","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":37,"column":46},"end":{"line":37,"column":55}},"replacement":"\"\"","id":"202","status":"Killed","testsCompleted":1},{"mutatorName":"StringLiteral","location":{"start":{"line":37,"column":78},"end":{"line":37,"column":87}},"replacement":"\"\"","id":"203","status":"Killed","testsCompleted":1},{"mutatorName":"ConditionalExpression","location":{"start":{"line":40,"column":9},"end":{"line":40,"column":18}},"replacement":"true","id":"204","status":"Killed","testsCompleted":1},{"mutatorName":"ConditionalExpression","location":{"start":{"line":40,"column":9},"end":{"line":40,"column":18}},"replacement":"false","id":"205","status":"Survived","testsCompleted":1}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/reporting/dashboard/Providers.scala":{"source":"package stryker4jvm.reporting.dashboard\n\nimport stryker4jvm.env.Environment\n\nobject Providers {\n  def determineCiProvider(env: Environment): Option[CiProvider] =\n    if (readEnvironmentVariable(\"TRAVIS\", env).isDefined) {\n      Some(new TravisProvider(env))\n    } else if (readEnvironmentVariable(\"CIRCLECI\", env).isDefined) {\n      Some(new CircleProvider(env))\n    } else if (readEnvironmentVariable(\"GITHUB_ACTION\", env).isDefined) {\n      Some(new GithubActionsProvider(env))\n    } else {\n      None\n    }\n\n  sealed trait CiProvider {\n    def determineProject(): Option[String]\n    def determineVersion(): Option[String]\n  }\n\n  private def readEnvironmentVariable(name: String, env: Environment): Option[String] =\n    env.get(name).filter(_.nonEmpty)\n\n  /** TODO: Only github projects are supported for now\n    */\n  private val githubCom = \"github.com\"\n\n  class TravisProvider(env: Environment) extends CiProvider {\n    override def determineProject(): Option[String] =\n      readEnvironmentVariable(\"TRAVIS_REPO_SLUG\", env)\n        .map(project => s\"$githubCom/$project\")\n\n    override def determineVersion(): Option[String] =\n      readEnvironmentVariable(\"TRAVIS_BRANCH\", env)\n  }\n\n  class CircleProvider(env: Environment) extends CiProvider {\n    override def determineProject(): Option[String] =\n      for {\n        username <- readEnvironmentVariable(\"CIRCLE_PROJECT_USERNAME\", env)\n        repoName <- readEnvironmentVariable(\"CIRCLE_PROJECT_REPONAME\", env)\n      } yield s\"$githubCom/$username/$repoName\"\n\n    override def determineVersion(): Option[String] =\n      readEnvironmentVariable(\"CIRCLE_BRANCH\", env)\n  }\n\n  class GithubActionsProvider(env: Environment) extends CiProvider {\n    override def determineProject(): Option[String] =\n      readEnvironmentVariable(\"GITHUB_REPOSITORY\", env)\n        .map(project => s\"$githubCom/$project\")\n\n    override def determineVersion(): Option[String] =\n      for {\n        ref <- readEnvironmentVariable(\"GITHUB_REF\", env)\n        refs = ref.split('/')\n        version <- refs match {\n          case Array(_, \"pull\", prNumber, _*) => Some(s\"PR-$prNumber\")\n          case Array(_, _, tail*)             => Some(tail.mkString(\"/\"))\n          case _                              => None\n        }\n        if version.nonEmpty\n      } yield version\n  }\n\n  // TODO: Support VSTS, GitLab CI\n}\n","mutants":[{"mutatorName":"ConditionalExpression","location":{"start":{"line":7,"column":9},"end":{"line":7,"column":57}},"replacement":"true","id":"373","status":"Killed","testsCompleted":12},{"mutatorName":"ConditionalExpression","location":{"start":{"line":7,"column":9},"end":{"line":7,"column":57}},"replacement":"false","id":"374","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":7,"column":33},"end":{"line":7,"column":41}},"replacement":"\"\"","id":"375","status":"Killed","testsCompleted":12},{"mutatorName":"ConditionalExpression","location":{"start":{"line":9,"column":16},"end":{"line":9,"column":66}},"replacement":"true","id":"376","status":"Killed","testsCompleted":12},{"mutatorName":"ConditionalExpression","location":{"start":{"line":9,"column":16},"end":{"line":9,"column":66}},"replacement":"false","id":"377","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":9,"column":40},"end":{"line":9,"column":50}},"replacement":"\"\"","id":"378","status":"Killed","testsCompleted":12},{"mutatorName":"ConditionalExpression","location":{"start":{"line":11,"column":16},"end":{"line":11,"column":71}},"replacement":"true","id":"379","status":"Survived","testsCompleted":12},{"mutatorName":"ConditionalExpression","location":{"start":{"line":11,"column":16},"end":{"line":11,"column":71}},"replacement":"false","id":"380","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":11,"column":40},"end":{"line":11,"column":55}},"replacement":"\"\"","id":"382","status":"Killed","testsCompleted":12},{"mutatorName":"MethodExpression","location":{"start":{"line":23,"column":5},"end":{"line":23,"column":37}},"replacement":"env.get(name).filterNot(_.nonEmpty)","id":"385","status":"Killed","testsCompleted":12},{"mutatorName":"MethodExpression","location":{"start":{"line":23,"column":26},"end":{"line":23,"column":36}},"replacement":"_.isEmpty","id":"386","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":27,"column":27},"end":{"line":27,"column":39}},"replacement":"\"\"","id":"387","status":"Ignored"},{"mutatorName":"StringLiteral","location":{"start":{"line":31,"column":31},"end":{"line":31,"column":49}},"replacement":"\"\"","id":"388","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":32,"column":25},"end":{"line":32,"column":47}},"replacement":"\"\"","id":"389","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":35,"column":31},"end":{"line":35,"column":46}},"replacement":"\"\"","id":"390","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":41,"column":45},"end":{"line":41,"column":70}},"replacement":"\"\"","id":"391","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":42,"column":45},"end":{"line":42,"column":70}},"replacement":"\"\"","id":"392","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":43,"column":15},"end":{"line":43,"column":48}},"replacement":"\"\"","id":"393","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":46,"column":31},"end":{"line":46,"column":46}},"replacement":"\"\"","id":"394","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":51,"column":31},"end":{"line":51,"column":50}},"replacement":"\"\"","id":"395","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":52,"column":25},"end":{"line":52,"column":47}},"replacement":"\"\"","id":"396","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":56,"column":40},"end":{"line":56,"column":52}},"replacement":"\"\"","id":"397","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":59,"column":25},"end":{"line":59,"column":31}},"replacement":"\"\"","id":"398","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":59,"column":55},"end":{"line":59,"column":70}},"replacement":"\"\"","id":"399","status":"Killed","testsCompleted":12},{"mutatorName":"StringLiteral","location":{"start":{"line":60,"column":69},"end":{"line":60,"column":72}},"replacement":"\"\"","id":"400","status":"Killed","testsCompleted":12},{"mutatorName":"MethodExpression","location":{"start":{"line":63,"column":12},"end":{"line":63,"column":28}},"replacement":"version.isEmpty","id":"401","status":"Killed","testsCompleted":12}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/exception/TestSetupException.scala":{"source":"package stryker4jvm.exception\n\nimport stryker4jvm.core.exception.Stryker4jvmException\n\nfinal case class TestSetupException(name: String)\n    extends Stryker4jvmException(\n      s\"Could not setup mutation testing environment. Unable to resolve project $name. This could be due to compile errors or misconfiguration of Stryker4jvm. See debug logs for more information.\"\n    )\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":7,"column":7},"end":{"line":7,"column":197}},"replacement":"\"\"","id":"3","status":"NoCoverage"}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/run/RollbackHandler.scala":{"source":"package stryker4jvm.run\n\nimport cats.data.NonEmptyList\nimport stryker4jvm.model.{CompilerErrMsg, MutantResultsPerFile, MutatedFile}\n\nclass RollbackHandler {\n  def rollbackFiles(\n      // errors: NonEmptyList[CompilerErrMsg],\n      // allFiles: Seq[MutatedFile]\n  ): Either[NonEmptyList[CompilerErrMsg], RollbackResult] = throw new NotImplementedError(\n    \"Rollback not implemented yet. If you need rollback, use release version v0.14.3\"\n  )\n\n  // private def compileErrorMutant(mutant: MutantWithId): MutantResult = mutant.toMutantResult(MutantStatus.CompileError)\n}\n\nfinal case class RollbackResult(newFiles: Seq[MutatedFile], compileErrors: MutantResultsPerFile)\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":11,"column":5},"end":{"line":11,"column":86}},"replacement":"\"\"","id":"8","status":"NoCoverage"}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/ScalaMutatorProvider.scala":{"source":"package stryker4jvm.mutator.scala\n\nimport stryker4jvm.core.config.LanguageMutatorConfig\nimport stryker4jvm.core.model.{InstrumenterOptions, LanguageMutator}\nimport stryker4jvm.core.model.languagemutator.LanguageMutatorProvider\nimport stryker4jvm.core.logging.Logger\nimport stryker4jvm.mutator.scala.ScalaMutatorProvider.parseDialect\n\nimport scala.meta.{dialects, Dialect};\n\n/** Class used to actually create and provide the scala mutator to stryker4jvm\n  */\nclass ScalaMutatorProvider extends LanguageMutatorProvider {\n  override def provideMutator(\n      languageMutatorConfig: LanguageMutatorConfig,\n      log: Logger,\n      instrumenterOptions: InstrumenterOptions\n  ): LanguageMutator[ScalaAST] = {\n    new ScalaMutator(\n      new ScalaParser(parseDialect(languageMutatorConfig.getDialect, log)),\n      new ScalaCollector(\n        traverser = new TraverserImpl()(log),\n        matcher = new MutantMatcherImpl(config = languageMutatorConfig)\n      )(log),\n      new ScalaInstrumenter(\n        options = ScalaInstrumenterOptions.fromJavaOptions(instrumenterOptions = instrumenterOptions)\n      )\n    )\n  }\n}\n\nobject ScalaMutatorProvider {\n  def parseDialect(configDialect: String, log: Logger): Dialect = {\n    val deprecatedVersions = List(\"scala211\", \"scala2.11\", \"2.11\", \"211\")\n    if (deprecatedVersions.contains(configDialect)) {\n      log.warn(\"Using deprecated Scala dialect\")\n      return dialects.Scala211\n    }\n\n    val defaultVersion = dialects.Scala213Source3\n    val scalaVersions = Map(\n      List(\"scala212\", \"scala2.12\", \"2.12\", \"212\") -> dialects.Scala212,\n      List(\"scala212source3\") -> dialects.Scala212Source3,\n      List(\"scala213\", \"scala2.13\", \"2.13\", \"213\", \"2\") -> dialects.Scala213,\n      List(\"scala213source3\", \"source3\") -> dialects.Scala213Source3,\n      List(\"scala3future\", \"future\") -> dialects.Scala3Future,\n      List(\"scala30\", \"scala3.0\", \"3.0\", \"30\", \"dotty\") -> dialects.Scala30,\n      List(\"scala31\", \"scala3.1\", \"3.1\", \"31\") -> dialects.Scala31,\n      List(\"scala32\", \"scala3.2\", \"3.2\", \"32\") -> dialects.Scala32,\n      List(\"scala3\", \"scala3.0\", \"3.0\", \"3\") -> dialects.Scala3\n    )\n    val dialectMap = scalaVersions.flatMap { case (versions, dialect) =>\n      versions.map(v => v -> dialect)\n    }\n    dialectMap.get(configDialect) match {\n      case Some(dialect) => dialect\n      case None =>\n        log.warn(s\"Unknown Scala dialect $configDialect, using default dialect $defaultVersion\")\n        defaultVersion\n    }\n  }\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":34,"column":35},"end":{"line":34,"column":45}},"replacement":"\"\"","id":"15","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":34,"column":47},"end":{"line":34,"column":58}},"replacement":"\"\"","id":"16","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":34,"column":60},"end":{"line":34,"column":66}},"replacement":"\"\"","id":"17","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":34,"column":68},"end":{"line":34,"column":73}},"replacement":"\"\"","id":"18","status":"Killed","testsCompleted":35},{"mutatorName":"ConditionalExpression","location":{"start":{"line":35,"column":9},"end":{"line":35,"column":51}},"replacement":"true","id":"19","status":"Killed","testsCompleted":35},{"mutatorName":"ConditionalExpression","location":{"start":{"line":35,"column":9},"end":{"line":35,"column":51}},"replacement":"false","id":"20","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":36,"column":16},"end":{"line":36,"column":48}},"replacement":"\"\"","id":"21","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":42,"column":12},"end":{"line":42,"column":22}},"replacement":"\"\"","id":"22","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":42,"column":24},"end":{"line":42,"column":35}},"replacement":"\"\"","id":"23","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":42,"column":37},"end":{"line":42,"column":43}},"replacement":"\"\"","id":"24","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":42,"column":45},"end":{"line":42,"column":50}},"replacement":"\"\"","id":"25","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":43,"column":12},"end":{"line":43,"column":29}},"replacement":"\"\"","id":"26","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":44,"column":12},"end":{"line":44,"column":22}},"replacement":"\"\"","id":"27","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":44,"column":24},"end":{"line":44,"column":35}},"replacement":"\"\"","id":"28","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":44,"column":37},"end":{"line":44,"column":43}},"replacement":"\"\"","id":"29","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":44,"column":45},"end":{"line":44,"column":50}},"replacement":"\"\"","id":"30","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":44,"column":52},"end":{"line":44,"column":55}},"replacement":"\"\"","id":"31","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":45,"column":12},"end":{"line":45,"column":29}},"replacement":"\"\"","id":"32","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":45,"column":31},"end":{"line":45,"column":40}},"replacement":"\"\"","id":"33","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":46,"column":12},"end":{"line":46,"column":26}},"replacement":"\"\"","id":"34","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":46,"column":28},"end":{"line":46,"column":36}},"replacement":"\"\"","id":"35","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":47,"column":12},"end":{"line":47,"column":21}},"replacement":"\"\"","id":"36","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":47,"column":23},"end":{"line":47,"column":33}},"replacement":"\"\"","id":"37","status":"Survived","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":47,"column":35},"end":{"line":47,"column":40}},"replacement":"\"\"","id":"38","status":"Survived","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":47,"column":42},"end":{"line":47,"column":46}},"replacement":"\"\"","id":"39","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":47,"column":48},"end":{"line":47,"column":55}},"replacement":"\"\"","id":"40","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":48,"column":12},"end":{"line":48,"column":21}},"replacement":"\"\"","id":"41","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":48,"column":23},"end":{"line":48,"column":33}},"replacement":"\"\"","id":"42","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":48,"column":35},"end":{"line":48,"column":40}},"replacement":"\"\"","id":"43","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":48,"column":42},"end":{"line":48,"column":46}},"replacement":"\"\"","id":"45","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":49,"column":12},"end":{"line":49,"column":21}},"replacement":"\"\"","id":"48","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":49,"column":23},"end":{"line":49,"column":33}},"replacement":"\"\"","id":"49","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":49,"column":35},"end":{"line":49,"column":40}},"replacement":"\"\"","id":"50","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":49,"column":42},"end":{"line":49,"column":46}},"replacement":"\"\"","id":"52","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":50,"column":12},"end":{"line":50,"column":20}},"replacement":"\"\"","id":"53","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":50,"column":22},"end":{"line":50,"column":32}},"replacement":"\"\"","id":"54","status":"Survived","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":50,"column":34},"end":{"line":50,"column":39}},"replacement":"\"\"","id":"55","status":"Survived","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":50,"column":41},"end":{"line":50,"column":44}},"replacement":"\"\"","id":"56","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":58,"column":18},"end":{"line":58,"column":96}},"replacement":"\"\"","id":"57","status":"Killed","testsCompleted":35}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/logging/FansiLogger.scala":{"source":"package stryker4jvm.logging\nimport fansi.Str\nimport stryker4jvm.core.logging.{LogLevel, Logger}\n\nclass FansiLogger(val coreLogger: Logger) {\n\n  final def log(level: LogLevel, msg: => String): Unit = coreLogger.log(level, msg)\n  final def log(level: LogLevel, msg: => String, e: => Throwable): Unit = coreLogger.log(level, msg, e)\n  final def log(level: LogLevel, throwable: Throwable): Unit = coreLogger.log(level, throwable)\n\n  final def debug(msg: => Str): Unit = logImpl(LogLevel.Debug, msg)\n  final def debug(msg: => Str, e: Throwable): Unit = logImpl(LogLevel.Debug, msg, e)\n  final def debug(e: Throwable): Unit = log(LogLevel.Debug, e)\n\n  final def info(msg: => Str): Unit = logImpl(LogLevel.Info, msg)\n  final def info(msg: => Str, e: Throwable): Unit = logImpl(LogLevel.Info, msg, e)\n  final def info(e: Throwable): Unit = log(LogLevel.Info, e)\n\n  final def warn(msg: => Str): Unit = logImpl(LogLevel.Warn, msg)\n  final def warn(msg: => Str, e: Throwable): Unit = logImpl(LogLevel.Warn, msg, e)\n  final def warn(e: Throwable): Unit = log(LogLevel.Warn, e)\n\n  final def error(msg: => Str): Unit = logImpl(LogLevel.Error, msg)\n  final def error(msg: => Str, e: Throwable): Unit = logImpl(LogLevel.Error, msg, e)\n  final def error(e: Throwable): Unit = log(LogLevel.Error, e)\n\n  final private def logImpl(level: LogLevel, msg: => Str): Unit = log(level, processMsgStr(msg))\n  final private def logImpl(level: LogLevel, msg: => Str, e: => Throwable): Unit = log(level, processMsgStr(msg), e)\n\n  /** Process a colored fansi.Str to a String, or plain text if colors are disabled */\n  @inline private def processMsgStr(msg: fansi.Str): String =\n    if (coreLogger.isColorEnabled) msg.render else msg.plainText\n}\n","mutants":[{"mutatorName":"ConditionalExpression","location":{"start":{"line":32,"column":9},"end":{"line":32,"column":34}},"replacement":"true","id":"1","status":"Killed","testsCompleted":89},{"mutatorName":"ConditionalExpression","location":{"start":{"line":32,"column":9},"end":{"line":32,"column":34}},"replacement":"false","id":"2","status":"Killed","testsCompleted":7}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/mutants/SupportedLanguageMutators.scala":{"source":"package stryker4jvm.mutants\n\nimport stryker4jvm.core.config.LanguageMutatorConfig\nimport stryker4jvm.core.exception.LanguageMutatorProviderException\nimport stryker4jvm.core.model.{AST, InstrumenterOptions, LanguageMutator}\nimport stryker4jvm.core.model.languagemutator.LanguageMutatorProvider\nimport stryker4jvm.mutator.kotlin.KotlinMutatorProvider\nimport stryker4jvm.mutator.scala.ScalaMutatorProvider\nimport stryker4jvm.logging.FansiLogger\n\ncase class SupportedProvider(\n    name: String,\n    directory: String,\n    extension: String,\n    languageProvider: LanguageMutatorProvider\n) {\n  def provideMutator(\n      config: LanguageMutatorConfig,\n      logger: FansiLogger,\n      options: InstrumenterOptions\n  ): LanguageMutator[? <: AST] =\n    languageProvider.provideMutator(config, logger.coreLogger, options).asInstanceOf[LanguageMutator[? <: AST]]\n}\n\nobject SupportedLanguageMutators {\n  val supportedProviders: Seq[SupportedProvider] = Seq(\n    SupportedProvider(\"kotlin\", \"kotlin\", \"kt\", new KotlinMutatorProvider),\n    SupportedProvider(\"scala\", \"scala\", \"scala\", new ScalaMutatorProvider)\n  )\n\n  def supportedMutators(\n      configs: Map[String, LanguageMutatorConfig],\n      logger: FansiLogger,\n      options: InstrumenterOptions\n  ): Map[String, LanguageMutator[? <: AST]] = {\n    val default = new LanguageMutatorConfig(null, new java.util.HashSet())\n    supportedProviders\n      .map(provider =>\n        try\n          Some(\n            \".\" + provider.extension -> provider\n              .provideMutator(configs.getOrElse(provider.name, default), logger, options)\n          )\n        catch {\n          case e: LanguageMutatorProviderException =>\n            logger.warn(\n              s\"Language mutator provider '${provider.languageProvider.getClass.getName}' threw an exception with message ${e.getMessage}; this mutator will be ignored.\"\n            )\n            None\n          case e: Throwable =>\n            logger.error(\n              s\"Language mutator provider '${provider.languageProvider.getClass.getName}' threw an unexpected exception with message ${e.getMessage}; this mutator will be ignored.\",\n              e\n            )\n            None\n        }\n      )\n      .filter(_.isDefined)\n      .map(_.get)\n      .toMap\n  }\n\n  def mutatesFileSources: Seq[String] =\n    supportedProviders.map(mutator => s\"**/main/${mutator.directory}/**.${mutator.extension}\")\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":27,"column":23},"end":{"line":27,"column":31}},"replacement":"\"\"","id":"96","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":27,"column":33},"end":{"line":27,"column":41}},"replacement":"\"\"","id":"97","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":27,"column":43},"end":{"line":27,"column":47}},"replacement":"\"\"","id":"98","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":28,"column":23},"end":{"line":28,"column":30}},"replacement":"\"\"","id":"99","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":28,"column":32},"end":{"line":28,"column":39}},"replacement":"\"\"","id":"100","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":28,"column":41},"end":{"line":28,"column":48}},"replacement":"\"\"","id":"101","status":"NoCoverage"},{"mutatorName":"MethodExpression","location":{"start":{"line":37,"column":5},"end":{"line":58,"column":27}},"replacement":"supportedProviders.map(provider => try Some(\".\" + provider.extension -> provider.provideMutator(configs.getOrElse(provider.name, default), logger, options)) catch {\n  case e: LanguageMutatorProviderException =>\n    logger.warn(s\"Language mutator provider '${provider.languageProvider.getClass.getName}' threw an exception with message ${e.getMessage}; this mutator will be ignored.\")\n    None\n  case e: Throwable =>\n    logger.error(s\"Language mutator provider '${provider.languageProvider.getClass.getName}' threw an unexpected exception with message ${e.getMessage}; this mutator will be ignored.\", e)\n    None\n}).filterNot(_.isDefined)","id":"102","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":41,"column":13},"end":{"line":41,"column":16}},"replacement":"\"\"","id":"103","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":47,"column":15},"end":{"line":47,"column":170}},"replacement":"\"\"","id":"104","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":52,"column":15},"end":{"line":52,"column":181}},"replacement":"\"\"","id":"105","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":64,"column":39},"end":{"line":64,"column":94}},"replacement":"\"\"","id":"106","status":"NoCoverage"}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/extensions/mutationtype/BooleanLiteral.scala":{"source":"package stryker4jvm.mutator.scala.extensions.mutationtype\n\nimport scala.meta.Lit\n\ncase object True extends BooleanLiteral {\n  override val tree: Lit.Boolean = Lit.Boolean(true)\n}\n\ncase object False extends BooleanLiteral {\n  override val tree: Lit.Boolean = Lit.Boolean(false)\n}\n","mutants":[{"mutatorName":"BooleanLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":6,"column":48},"end":{"line":6,"column":52}},"replacement":"false","id":"150","status":"Ignored"},{"mutatorName":"BooleanLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":10,"column":48},"end":{"line":10,"column":53}},"replacement":"true","id":"151","status":"Ignored"}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/run/MutantRunner.scala":{"source":"package stryker4jvm.run\n\nimport cats.data.{EitherT, NonEmptyList}\nimport cats.effect.{IO, Resource}\nimport cats.syntax.all.*\nimport fs2.io.file.{Files, Path}\nimport fs2.{text, Pipe, Stream}\nimport mutationtesting.{MutantResult, MutantStatus}\nimport stryker4jvm.config.Config\nimport stryker4jvm.core.model.{AST, MutantWithId}\nimport stryker4jvm.exception.{InitialTestRunFailedException, UnableToFixCompilerErrorsException}\nimport stryker4jvm.extensions.FileExtensions.PathExtensions\nimport stryker4jvm.extensions.MutantExtensions.ToMutantResultExtension\nimport stryker4jvm.files.FilesFileResolver\nimport stryker4jvm.logging.FansiLogger\nimport stryker4jvm.model.*\nimport stryker4jvm.reporting.{IOReporter, MutantTestedEvent}\n\nimport java.nio\nimport scala.collection.immutable.SortedMap\nimport scala.collection.mutable\n\nclass MutantRunner(\n    createTestRunnerPool: Path => Either[NonEmptyList[CompilerErrMsg], Resource[IO, TestRunnerPool]],\n    fileResolver: FilesFileResolver,\n    rollbackHandler: RollbackHandler,\n    reporter: IOReporter\n)(implicit config: Config, log: FansiLogger) {\n\n  def apply(mutatedFiles: Seq[MutatedFile]): IO[RunResult] = {\n\n    val withRollback = handleRollback(mutatedFiles)\n\n    withRollback\n\n  }\n\n  def handleRollback(mutatedFiles: Seq[MutatedFile]): IO[RunResult] =\n    EitherT(run(mutatedFiles))\n      .leftFlatMap { errors =>\n        log.info(s\"Attempting to remove ${errors.size} mutants that gave a compile error...\")\n        // Retry once with the non-compiling mutants removed\n        EitherT(\n          rollbackHandler\n            .rollbackFiles()\n            // TODO: handle rollbacks in a different place\n            .flatTraverse { case RollbackResult(newFiles, rollbackedMutants) =>\n              run(newFiles).map { result =>\n                result.map { r =>\n                  r.copy(results = r.results.alignCombine(rollbackedMutants))\n                }\n              }\n\n            }\n        )\n      }\n      // Failed at removing the non-compiling mutants\n      .leftMap(UnableToFixCompilerErrorsException(_))\n      .rethrowT\n\n  def run(mutatedFiles: Seq[MutatedFile]): IO[Either[NonEmptyList[CompilerErrMsg], RunResult]] = {\n    prepareEnv(mutatedFiles).use { path =>\n      createTestRunnerPool(path).traverse {\n        _.use { testRunnerPool =>\n          testRunnerPool.loan\n            .use(testrunner => initialTestRun(testrunner))\n            .flatMap(coverageExclusions => runMutants(mutatedFiles, testRunnerPool, coverageExclusions).timed)\n            .map(t => RunResult(t._2, t._1))\n        }\n      }\n    }\n  }\n\n  def prepareEnv(mutatedFiles: Seq[MutatedFile]): Resource[IO, Path] = {\n    val targetDir = config.baseDir / \"target\"\n    for {\n      _ <- Resource.eval(Files[IO].createDirectories(targetDir))\n      tmpDir <- prepareTmpDir(targetDir)\n      _ <- Resource.eval(setupFiles(tmpDir, mutatedFiles.toSeq))\n    } yield tmpDir\n  }\n\n  private def prepareTmpDir(targetDir: Path): Resource[IO, Path] = {\n    val tmpDirCreated = if (config.staticTmpDir) {\n      val staticTmpDir = targetDir / \"stryker4jvm-tmpDir\"\n      Files[IO].createDirectory(staticTmpDir).as(staticTmpDir)\n    } else {\n      Files[IO].createTempDirectory(Some(targetDir), \"stryker4jvm-\", None)\n    }\n    Resource.makeCase(tmpDirCreated)(tmpDirFinalizeCase)\n  }\n\n  private def tmpDirFinalizeCase: (Path, Resource.ExitCase) => IO[Unit] = {\n    case (tmpDir, Resource.ExitCase.Succeeded | Resource.ExitCase.Canceled) =>\n      if (config.cleanTmpDir) {\n        Files[IO].deleteRecursively(tmpDir)\n      } else {\n        IO(\n          log.info(\n            s\"Not deleting $tmpDir (turn off cleanTmpDir to disable this). Please clean it up manually.\"\n          )\n        )\n      }\n    case (tmpDir, _: Resource.ExitCase.Errored) =>\n      // Enable the user do some manual actions before she retries.\n      IO(\n        log.warn(\n          s\"Not deleting $tmpDir after error. Please clean it up manually.\"\n        )\n      )\n  }\n\n  private def setupFiles(tmpDir: Path, mutatedFiles: Seq[MutatedFile]): IO[Unit] =\n    IO(log.info(\"Setting up mutated environment...\")) *>\n      IO(log.debug(\"Using temp directory: \" + tmpDir)) *> {\n        val mutatedPaths = mutatedFiles.map(_.fileOrigin)\n        val unmutatedFilesStream =\n          fileResolver.files\n            .filterNot(mutatedPaths.contains)\n            .through(writeOriginalFile(tmpDir))\n\n        val mutatedFilesStream = Stream\n          .emits(mutatedFiles)\n          .through(writeMutatedFile(tmpDir))\n        (unmutatedFilesStream merge mutatedFilesStream).compile.drain\n      }\n\n  def writeOriginalFile(tmpDir: Path): Pipe[IO, Path, Unit] =\n    in =>\n      in.parEvalMapUnordered(config.concurrency) { file =>\n        val newSubPath = file.inSubDir(tmpDir)\n\n        IO(log.debug(s\"Copying $file to $newSubPath\")) *>\n          Files[IO].createDirectories(newSubPath.parent.get) *>\n          Files[IO].copy(file, newSubPath).void\n      }\n\n  def writeMutatedFile(tmpDir: Path): Pipe[IO, MutatedFile, Unit] =\n    _.parEvalMap(config.concurrency) { mutatedFile =>\n      val targetPath = mutatedFile.fileOrigin.inSubDir(tmpDir)\n      IO(log.debug(s\"Writing ${mutatedFile.fileOrigin} file to $targetPath\")) *>\n        Files[IO]\n          .createDirectories(targetPath.parent.get)\n          .as((mutatedFile, targetPath))\n    }.map { case (mutatedFile, targetPath) =>\n      Stream(mutatedFile.mutatedSource.syntax)\n        .covary[IO]\n        .through(text.utf8.encode)\n        .through(Files[IO].writeAll(targetPath))\n    }.parJoin(config.concurrency)\n\n  private def runMutants(\n      mutatedFiles: Seq[MutatedFile],\n      testRunnerPool: TestRunnerPool,\n      coverageExclusions: CoverageExclusions\n  ): IO[MutantResultsPerFile] = {\n    val allMutants = mutatedFiles.flatMap(m => m.mutants.toVector.map(m.fileOrigin -> _))\n\n    val (staticMutants, rest) = allMutants.partition(m => coverageExclusions.staticMutants.contains(m._2.id))\n\n    val (noCoverageMutants, testableMutants) =\n      rest.partition(m => coverageExclusions.hasCoverage && !coverageExclusions.coveredMutants.contains(m._2.id))\n\n    // val compilerErrorMutants =\n    //   mutatedFiles.flatMap(m => m.nonCompilingMutants.toList.map(m.fileOrigin.relativePath -> _))\n\n    if (noCoverageMutants.nonEmpty) {\n      log.info(\n        s\"${noCoverageMutants.size} mutants detected as having no code coverage. They will be skipped and marked as NoCoverage\"\n      )\n      log.debug(s\"NoCoverage mutant ids are: ${noCoverageMutants.map(_._2.id).mkString(\", \")}\")\n    }\n\n    if (staticMutants.nonEmpty) {\n      log.info(\n        s\"${staticMutants.size} mutants detected as static. They will be skipped and marked as Ignored\"\n      )\n      log.debug(s\"Static mutant ids are: ${staticMutants.map(_._2.id).mkString(\", \")}\")\n    }\n\n    // TODO: move logging of compile-errors\n    // if (compilerErrorMutants.nonEmpty) {\n    //   log.info(\n    //     s\"${compilerErrorMutants.size} mutants gave a compiler error. They will be marked as such in the report.\"\n    //   )\n    //   log.debug(s\"Non-compiling mutant ids are: ${compilerErrorMutants.map(_._2.id.value).mkString(\", \")}\")\n    // }\n\n    def mapPureMutants[K, V, VV](l: Seq[(K, V)], f: V => VV) =\n      Stream.emits(l).map { case (k, v) => k -> f(v) }\n\n    // Map all static mutants\n    val static = mapPureMutants(staticMutants, staticMutant)\n    // Map all no-coverage mutants\n    val noCoverage = mapPureMutants(noCoverageMutants, noCoverageMutant(_))\n\n    // Run all testable mutants\n    val totalTestableMutants = testableMutants.size\n    val testedMutants = Stream\n      .emits(testableMutants)\n      .through(testRunnerPool.run { case (testRunner, (path, mutant)) =>\n        val coverageForMutant = coverageExclusions.coveredMutants.getOrElse(mutant.id, Seq.empty)\n        IO(log.debug(s\"Running mutant $mutant\")) *>\n          testRunner.runMutant(mutant, coverageForMutant).tupleLeft(path)\n      })\n      .observe(in => in.as(MutantTestedEvent(totalTestableMutants)).through(reporter.mutantTested))\n\n    // Back to per-file structure\n    implicit val pathOrdering: Ordering[Path] = implicitly[Ordering[nio.file.Path]].on[Path](_.toNioPath)\n    implicit val mutantResultOrdering: Ordering[MutantResult] = Ordering.String.on[MutantResult](_.id)\n    type MutantResultBuilder = mutable.Builder[MutantResult, Vector[MutantResult]]\n\n    (static ++ noCoverage ++ testedMutants)\n      .fold(SortedMap.empty[Path, MutantResultBuilder]) { case (resultsMap, (path, result)) =>\n        val results: MutantResultBuilder = resultsMap.getOrElse(path, Vector.newBuilder) += result\n        resultsMap + (path -> results)\n      }\n      .compile\n      .lastOrError\n      .map(_.map { case (k, v) => k -> v.result().sorted })\n  }\n\n  def initialTestRun(testRunner: TestRunner): IO[CoverageExclusions] = {\n    IO(log.info(\"Starting initial test run...\")) *>\n      testRunner.initialTestRun().flatMap { result =>\n        if (!result.isSuccessful)\n          IO.raiseError(\n            InitialTestRunFailedException(\n              \"Initial test run failed. Please make sure your tests pass before running Stryker4s.\"\n            )\n          )\n        else\n          IO(log.info(\"Initial test run succeeded! Testing mutants...\")).as {\n            result match {\n              case _: NoCoverageInitialTestRun => CoverageExclusions(hasCoverage = false, Map.empty, List.empty)\n              case InitialTestRunCoverageReport(_, firstRun, secondRun, _) =>\n                val firstRunMap = firstRun.report\n                val secondRunMap = secondRun.report\n                val staticMutants = (firstRunMap -- (secondRunMap.keys)).keys.toSeq\n\n                val coveredMutants = firstRunMap.filterNot { case (id, _) => staticMutants.contains(id) }\n\n                CoverageExclusions(hasCoverage = true, staticMutants = staticMutants, coveredMutants = coveredMutants)\n            }\n          }\n      }\n  }\n\n  private def staticMutant(mutant: MutantWithId[AST]): MutantResult = mutant\n    .toMutantResult(MutantStatus.Ignored)\n    .copy(\n      description = Some(\n        \"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.\"\n      ),\n      static = true.some\n    )\n\n  private def noCoverageMutant(mutant: MutantWithId[AST]): MutantResult = mutant\n    .toMutantResult(MutantStatus.Ignored)\n    .copy(\n      description =\n        \"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.\".some,\n      static = true.some\n    )\n\n  case class CoverageExclusions(\n      hasCoverage: Boolean,\n      coveredMutants: Map[Int, Seq[String]],\n      staticMutants: Seq[Int]\n  )\n\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":41,"column":18},"end":{"line":41,"column":93}},"replacement":"\"\"","id":"28","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":75,"column":38},"end":{"line":75,"column":46}},"replacement":"\"\"","id":"29","status":"Killed","testsCompleted":5},{"mutatorName":"ConditionalExpression","location":{"start":{"line":84,"column":29},"end":{"line":84,"column":48}},"replacement":"true","id":"31","status":"Killed","testsCompleted":5},{"mutatorName":"ConditionalExpression","location":{"start":{"line":84,"column":29},"end":{"line":84,"column":48}},"replacement":"false","id":"32","status":"Killed","testsCompleted":5},{"mutatorName":"StringLiteral","location":{"start":{"line":85,"column":38},"end":{"line":85,"column":58}},"replacement":"\"\"","id":"33","status":"Killed","testsCompleted":4},{"mutatorName":"StringLiteral","location":{"start":{"line":88,"column":54},"end":{"line":88,"column":68}},"replacement":"\"\"","id":"35","status":"Survived","testsCompleted":5},{"mutatorName":"ConditionalExpression","location":{"start":{"line":95,"column":11},"end":{"line":95,"column":29}},"replacement":"true","id":"45","status":"Killed","testsCompleted":5},{"mutatorName":"ConditionalExpression","location":{"start":{"line":95,"column":11},"end":{"line":95,"column":29}},"replacement":"false","id":"46","status":"Killed","testsCompleted":5},{"mutatorName":"StringLiteral","location":{"start":{"line":100,"column":13},"end":{"line":100,"column":105}},"replacement":"\"\"","id":"47","status":"Killed","testsCompleted":5},{"mutatorName":"StringLiteral","location":{"start":{"line":108,"column":11},"end":{"line":108,"column":76}},"replacement":"\"\"","id":"48","status":"Killed","testsCompleted":5},{"mutatorName":"StringLiteral","location":{"start":{"line":114,"column":17},"end":{"line":114,"column":52}},"replacement":"\"\"","id":"49","status":"Killed","testsCompleted":5},{"mutatorName":"StringLiteral","location":{"start":{"line":115,"column":20},"end":{"line":115,"column":44}},"replacement":"\"\"","id":"50","status":"Killed","testsCompleted":5},{"mutatorName":"MethodExpression","location":{"start":{"line":118,"column":11},"end":{"line":119,"column":46}},"replacement":"fileResolver.files.filter(mutatedPaths.contains)","id":"51","status":"Killed","testsCompleted":5},{"mutatorName":"StringLiteral","location":{"start":{"line":133,"column":22},"end":{"line":133,"column":53}},"replacement":"\"\"","id":"52","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":141,"column":20},"end":{"line":141,"column":76}},"replacement":"\"\"","id":"53","status":"Killed","testsCompleted":5},{"mutatorName":"LogicalOperator","location":{"start":{"line":162,"column":58},"end":{"line":162,"column":60}},"replacement":"||","id":"54","status":"Killed","testsCompleted":5},{"mutatorName":"ConditionalExpression","location":{"start":{"line":167,"column":9},"end":{"line":167,"column":35}},"replacement":"true","id":"55","status":"Killed","testsCompleted":5},{"mutatorName":"ConditionalExpression","location":{"start":{"line":167,"column":9},"end":{"line":167,"column":35}},"replacement":"false","id":"56","status":"Killed","testsCompleted":5},{"mutatorName":"MethodExpression","location":{"start":{"line":167,"column":9},"end":{"line":167,"column":35}},"replacement":"noCoverageMutants.isEmpty","id":"57","status":"Killed","testsCompleted":5},{"mutatorName":"StringLiteral","location":{"start":{"line":169,"column":9},"end":{"line":169,"column":128}},"replacement":"\"\"","id":"58","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":171,"column":17},"end":{"line":171,"column":95}},"replacement":"\"\"","id":"59","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":171,"column":88},"end":{"line":171,"column":92}},"replacement":"\"\"","id":"60","status":"NoCoverage"},{"mutatorName":"ConditionalExpression","location":{"start":{"line":174,"column":9},"end":{"line":174,"column":31}},"replacement":"true","id":"61","status":"Killed","testsCompleted":5},{"mutatorName":"ConditionalExpression","location":{"start":{"line":174,"column":9},"end":{"line":174,"column":31}},"replacement":"false","id":"62","status":"Killed","testsCompleted":5},{"mutatorName":"MethodExpression","location":{"start":{"line":174,"column":9},"end":{"line":174,"column":31}},"replacement":"staticMutants.isEmpty","id":"63","status":"Killed","testsCompleted":5},{"mutatorName":"StringLiteral","location":{"start":{"line":176,"column":9},"end":{"line":176,"column":104}},"replacement":"\"\"","id":"64","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":178,"column":17},"end":{"line":178,"column":87}},"replacement":"\"\"","id":"65","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":178,"column":80},"end":{"line":178,"column":84}},"replacement":"\"\"","id":"66","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":203,"column":22},"end":{"line":203,"column":47}},"replacement":"\"\"","id":"67","status":"Killed","testsCompleted":5},{"mutatorName":"StringLiteral","location":{"start":{"line":224,"column":17},"end":{"line":224,"column":47}},"replacement":"\"\"","id":"68","status":"Killed","testsCompleted":5},{"mutatorName":"ConditionalExpression","location":{"start":{"line":226,"column":13},"end":{"line":226,"column":33}},"replacement":"true","id":"69","status":"Killed","testsCompleted":1},{"mutatorName":"ConditionalExpression","location":{"start":{"line":226,"column":13},"end":{"line":226,"column":33}},"replacement":"false","id":"70","status":"Killed","testsCompleted":5},{"mutatorName":"StringLiteral","location":{"start":{"line":229,"column":15},"end":{"line":229,"column":100}},"replacement":"\"\"","id":"71","status":"Killed","testsCompleted":4},{"mutatorName":"StringLiteral","location":{"start":{"line":233,"column":23},"end":{"line":233,"column":71}},"replacement":"\"\"","id":"72","status":"Killed","testsCompleted":5},{"mutatorName":"BooleanLiteral","location":{"start":{"line":235,"column":84},"end":{"line":235,"column":89}},"replacement":"true","id":"73","status":"Killed","testsCompleted":5},{"mutatorName":"MethodExpression","location":{"start":{"line":241,"column":38},"end":{"line":241,"column":106}},"replacement":"firstRunMap.filter({\n  case (id, _) =>\n    staticMutants.contains(id)\n})","id":"74","status":"Killed","testsCompleted":5},{"mutatorName":"BooleanLiteral","location":{"start":{"line":243,"column":50},"end":{"line":243,"column":54}},"replacement":"false","id":"75","status":"Killed","testsCompleted":5},{"mutatorName":"StringLiteral","location":{"start":{"line":253,"column":9},"end":{"line":253,"column":176}},"replacement":"\"\"","id":"76","status":"NoCoverage"},{"mutatorName":"BooleanLiteral","location":{"start":{"line":255,"column":16},"end":{"line":255,"column":20}},"replacement":"false","id":"77","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":262,"column":9},"end":{"line":262,"column":176}},"replacement":"\"\"","id":"78","status":"NoCoverage"},{"mutatorName":"BooleanLiteral","location":{"start":{"line":263,"column":16},"end":{"line":263,"column":20}},"replacement":"false","id":"79","status":"NoCoverage"}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/reporting/reporters/DashboardReporter.scala":{"source":"package stryker4jvm.reporting.reporters\n\nimport cats.data.Validated.{Invalid, Valid}\nimport cats.effect.{IO, Resource}\nimport cats.syntax.foldable.*\nimport fansi.Color.Red\nimport fansi.{Bold, Str}\nimport io.circe.Error\nimport mutationtesting.{MetricsResult, MutationTestResult}\nimport stryker4jvm.config.{Config, Full, MutationScoreOnly}\nimport stryker4jvm.logging.FansiLogger\nimport stryker4jvm.reporting.{FinishedRunEvent, IOReporter}\nimport stryker4jvm.reporting.dashboard.DashboardConfigProvider\nimport stryker4jvm.reporting.model.*\nimport sttp.client3.*\nimport sttp.client3.circe.{asJson, circeBodySerializer}\nimport sttp.model.{MediaType, StatusCode}\n\nclass DashboardReporter(dashboardConfigProvider: DashboardConfigProvider)(implicit\n    log: FansiLogger,\n    httpBackend: Resource[IO, SttpBackend[IO, Any]]\n) extends IOReporter {\n\n  override def onRunFinished(runReport: FinishedRunEvent): IO[Unit] =\n    dashboardConfigProvider.resolveConfig() match {\n      case Invalid(configKeys) =>\n        val configKeysStr = Str.join(configKeys.map(c => Str(\"'\", Bold.On(c), \"'\")).toList, \", \")\n        IO(log.warn(s\"Could not resolve dashboard configuration key(s) $configKeysStr. Not sending report.\"))\n      case Valid(dashboardConfig) =>\n        val request = buildRequest(dashboardConfig, runReport.report, runReport.metrics)\n        httpBackend\n          .use(request.send(_))\n          .map(logResponse(_))\n    }\n\n  def buildRequest(dashConfig: DashboardConfig, report: MutationTestResult[Config], metrics: MetricsResult) = {\n    import io.circe.{Decoder, Encoder}\n    implicit val decoder: Decoder[DashboardPutResult] = Decoder.forProduct1(\"href\")(DashboardPutResult.apply)\n    // Separate so any slashes won't be escaped in project or version\n    val baseUrl = s\"${dashConfig.baseUrl}/api/reports/${dashConfig.project}/${dashConfig.version}\"\n    val uri = uri\"$baseUrl?module=${dashConfig.module}\"\n    val request = basicRequest\n      .header(\"X-Api-Key\", dashConfig.apiKey)\n      .contentType(MediaType.ApplicationJson)\n      .response(asJson[DashboardPutResult])\n      .put(uri)\n    dashConfig.reportType match {\n      case Full =>\n        import mutationtesting.circe.*\n        request\n          .body(report)\n      case MutationScoreOnly =>\n        implicit val encoder: Encoder[ScoreOnlyReport] = Encoder.forProduct1(\"mutationScore\")(r => r.mutationScore)\n        request\n          .body(ScoreOnlyReport(metrics.mutationScore))\n    }\n  }\n\n  private def logResponse(response: Response[Either[ResponseException[String, Error], DashboardPutResult]]): Unit =\n    response.body match {\n      case Left(HttpError(errorBody, StatusCode.Unauthorized)) =>\n        log.error(\n          s\"Error HTTP PUT '$errorBody'. Status code ${Red(\"401 Unauthorized\")}. Did you provide the correct api key in the '${Bold\n              .On(\"STRYKER_DASHBOARD_API_KEY\")}' environment variable?\"\n        )\n      case Left(HttpError(errorBody, statusCode)) =>\n        log.error(\n          s\"Failed to PUT report to dashboard. Response status code: ${Red(statusCode.code.toString())}. Response body: '$errorBody'\"\n        )\n      case Left(DeserializationException(original, error)) =>\n        log.warn(\n          s\"Dashboard report was sent successfully, but could not decode the response: '$original'. Error:\",\n          error\n        )\n      case Right(DashboardPutResult(href)) =>\n        log.info(s\"Sent report to dashboard. Available at $href\")\n    }\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":27,"column":62},"end":{"line":27,"column":65}},"replacement":"\"\"","id":"351","status":"Killed","testsCompleted":8},{"mutatorName":"StringLiteral","location":{"start":{"line":27,"column":79},"end":{"line":27,"column":82}},"replacement":"\"\"","id":"352","status":"Killed","testsCompleted":8},{"mutatorName":"StringLiteral","location":{"start":{"line":27,"column":93},"end":{"line":27,"column":97}},"replacement":"\"\"","id":"353","status":"Killed","testsCompleted":8},{"mutatorName":"StringLiteral","location":{"start":{"line":28,"column":21},"end":{"line":28,"column":108}},"replacement":"\"\"","id":"354","status":"Killed","testsCompleted":8},{"mutatorName":"StringLiteral","location":{"start":{"line":38,"column":77},"end":{"line":38,"column":83}},"replacement":"\"\"","id":"355","status":"Survived","testsCompleted":8},{"mutatorName":"StringLiteral","location":{"start":{"line":40,"column":19},"end":{"line":40,"column":99}},"replacement":"\"\"","id":"356","status":"Killed","testsCompleted":8},{"mutatorName":"StringLiteral","location":{"start":{"line":43,"column":15},"end":{"line":43,"column":26}},"replacement":"\"\"","id":"357","status":"Killed","testsCompleted":8},{"mutatorName":"StringLiteral","location":{"start":{"line":53,"column":78},"end":{"line":53,"column":93}},"replacement":"\"\"","id":"358","status":"Killed","testsCompleted":8},{"mutatorName":"StringLiteral","location":{"start":{"line":63,"column":11},"end":{"line":64,"column":72}},"replacement":"\"\"","id":"359","status":"Killed","testsCompleted":8},{"mutatorName":"StringLiteral","location":{"start":{"line":63,"column":60},"end":{"line":63,"column":78}},"replacement":"\"\"","id":"360","status":"Killed","testsCompleted":8},{"mutatorName":"StringLiteral","location":{"start":{"line":64,"column":19},"end":{"line":64,"column":46}},"replacement":"\"\"","id":"361","status":"Killed","testsCompleted":8},{"mutatorName":"StringLiteral","location":{"start":{"line":68,"column":11},"end":{"line":68,"column":134}},"replacement":"\"\"","id":"362","status":"Killed","testsCompleted":8},{"mutatorName":"StringLiteral","location":{"start":{"line":72,"column":11},"end":{"line":72,"column":108}},"replacement":"\"\"","id":"363","status":"Killed","testsCompleted":8},{"mutatorName":"StringLiteral","location":{"start":{"line":76,"column":18},"end":{"line":76,"column":65}},"replacement":"\"\"","id":"364","status":"Killed","testsCompleted":8}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/extensions/mutationtype/ArgMethodExpression.scala":{"source":"package stryker4jvm.mutator.scala.extensions.mutationtype\n\nimport scala.meta.Term\nimport scala.meta.Term.*\n\n/** Base trait for method calls with one or multiple argument(s)\n  */\nsealed trait ArgMethodExpression extends MethodExpression {\n  def unapply(term: Term): Option[(Term, String => Term)] =\n    term match {\n      // foo.filter { (a,b) => a > b }\n      case Apply(Select(_, Name(`methodName`)), Block(Function(_ :: _ :: _, _) :: Nil) :: Nil) =>\n        None\n\n      // foo.filter((a,b) => a > b)\n      case Apply(Select(_, Name(`methodName`)), Function(_ :: _ :: _, _) :: Nil) =>\n        None\n\n      // foo filter { (a,b) => a > b }\n      case ApplyInfix(_, Name(`methodName`), Nil, Block(Function(_ :: _ :: _, _) :: Nil) :: Nil) =>\n        None\n\n      // foo filter((a,b) => a > b)\n      case ApplyInfix(_, Name(`methodName`), Nil, Function(_ :: _ :: _, _) :: Nil) =>\n        None\n\n      // foo.filter( a => a > 0 )\n      case Apply(Select(q, Name(`methodName`)), arg :: Nil) =>\n        Option((term, name => Apply(Term.Select(q, Name(name)), arg :: Nil)))\n\n      // foo filter( a => a > 0 )\n      case ApplyInfix(q, Name(`methodName`), Nil, arg :: Nil) =>\n        Option((term, name => ApplyInfix(q, Name(name), Nil, arg :: Nil)))\n\n      case _ => None\n    }\n}\n\ncase object Filter extends ArgMethodExpression {\n  protected val methodName = \"filter\"\n}\n\ncase object FilterNot extends ArgMethodExpression {\n  protected val methodName = \"filterNot\"\n}\n\ncase object Exists extends ArgMethodExpression {\n  protected val methodName = \"exists\"\n}\n\ncase object Forall extends ArgMethodExpression {\n  protected val methodName = \"forall\"\n}\n\ncase object Take extends ArgMethodExpression {\n  protected val methodName = \"take\"\n}\n\ncase object Drop extends ArgMethodExpression {\n  protected val methodName = \"drop\"\n}\n\ncase object TakeRight extends ArgMethodExpression {\n  protected val methodName = \"takeRight\"\n}\n\ncase object DropRight extends ArgMethodExpression {\n  protected val methodName = \"dropRight\"\n}\n\ncase object TakeWhile extends ArgMethodExpression {\n  protected val methodName = \"takeWhile\"\n}\n\ncase object DropWhile extends ArgMethodExpression {\n  protected val methodName = \"dropWhile\"\n}\n\ncase object IndexOf extends ArgMethodExpression {\n  protected val methodName = \"indexOf\"\n}\n\ncase object LastIndexOf extends ArgMethodExpression {\n  protected val methodName = \"lastIndexOf\"\n}\n\ncase object MaxBy extends ArgMethodExpression {\n  protected val methodName = \"maxBy\"\n}\n\ncase object MinBy extends ArgMethodExpression {\n  protected val methodName = \"minBy\"\n}\n","mutants":[{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":40,"column":30},"end":{"line":40,"column":38}},"replacement":"\"\"","id":"111","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":44,"column":30},"end":{"line":44,"column":41}},"replacement":"\"\"","id":"112","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":48,"column":30},"end":{"line":48,"column":38}},"replacement":"\"\"","id":"113","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":52,"column":30},"end":{"line":52,"column":38}},"replacement":"\"\"","id":"114","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":56,"column":30},"end":{"line":56,"column":36}},"replacement":"\"\"","id":"115","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":60,"column":30},"end":{"line":60,"column":36}},"replacement":"\"\"","id":"116","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":64,"column":30},"end":{"line":64,"column":41}},"replacement":"\"\"","id":"117","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":68,"column":30},"end":{"line":68,"column":41}},"replacement":"\"\"","id":"118","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":72,"column":30},"end":{"line":72,"column":41}},"replacement":"\"\"","id":"119","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":76,"column":30},"end":{"line":76,"column":41}},"replacement":"\"\"","id":"120","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":80,"column":30},"end":{"line":80,"column":39}},"replacement":"\"\"","id":"121","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":84,"column":30},"end":{"line":84,"column":43}},"replacement":"\"\"","id":"122","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":88,"column":30},"end":{"line":88,"column":37}},"replacement":"\"\"","id":"123","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":92,"column":30},"end":{"line":92,"column":37}},"replacement":"\"\"","id":"124","status":"Ignored"}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/extensions/Stryker4jvmCoreConversions.scala":{"source":"package stryker4jvm.mutator.scala.extensions\n\nimport stryker4jvm.core.model.elements.{Location, MutantResult, MutantStatus, Position}\n\nimport java.util.Optional\nimport scala.collection.JavaConverters.seqAsJavaList\nimport scala.collection.convert.ImplicitConversions.`collection AsScalaIterable`\n\nobject Stryker4jvmCoreConversions {\n  implicit final class CoreMutantResultExtension(result: MutantResult) {\n    def asMutationElement: mutationtesting.MutantResult = {\n      mutationtesting.MutantResult(\n        result.id,\n        result.mutatorName,\n        result.replacement,\n        result.location.asMutationElement,\n        result.mutantStatus.asMutationElement,\n        result.statusReason.asScala,\n        result.description.asScala,\n        result.coveredBy.asScala.map(_.toSeq),\n        result.killedBy.asScala.map(_.toSeq),\n        result.testsCompleted.asScala.map(_.intValue()),\n        result.isStatic.asScala.map(_.booleanValue())\n      )\n    }\n  }\n\n  implicit final class MutantResultExtension(result: mutationtesting.MutantResult) {\n    def asCoreElement: MutantResult = {\n      new MutantResult(\n        result.id,\n        result.mutatorName,\n        result.replacement,\n        result.location.asCoreElement,\n        result.status.asCoreElement,\n        result.statusReason.orNull,\n        result.description.orNull,\n        result.coveredBy.map(seqAsJavaList).orNull,\n        result.killedBy.map(seqAsJavaList).orNull,\n        result.testsCompleted.map(Integer.valueOf).orNull,\n        result.static.map(Boolean.box).orNull\n      )\n    }\n  }\n\n  implicit final class JavaOptionalExtension[A](optional: Optional[A]) {\n    def asScala: Option[A] = {\n      if (optional.isPresent)\n        Option(optional.get())\n      else\n        Option.empty\n    }\n  }\n\n  implicit final class ScalaOptionalExtension[A](option: Option[A]) {\n    def asJava: Optional[A] = {\n      if (option.isDefined)\n        Optional.of(option.get)\n      else\n        Optional.empty()\n    }\n  }\n\n  implicit final class CoreMutantStatusExtension(status: MutantStatus) {\n    implicit def asMutationElement: mutationtesting.MutantStatus = {\n      status match {\n        case MutantStatus.Killed       => mutationtesting.MutantStatus.Killed\n        case MutantStatus.Survived     => mutationtesting.MutantStatus.Survived\n        case MutantStatus.NoCoverage   => mutationtesting.MutantStatus.NoCoverage\n        case MutantStatus.Timeout      => mutationtesting.MutantStatus.Timeout\n        case MutantStatus.CompileError => mutationtesting.MutantStatus.CompileError\n        case MutantStatus.RuntimeError => mutationtesting.MutantStatus.RuntimeError\n        case MutantStatus.Ignored      => mutationtesting.MutantStatus.Ignored\n      }\n    }\n  }\n\n  implicit final class MutantStatusExtension(status: mutationtesting.MutantStatus) {\n    implicit def asCoreElement: MutantStatus = status match {\n      case mutationtesting.MutantStatus.Killed       => MutantStatus.Killed\n      case mutationtesting.MutantStatus.Survived     => MutantStatus.Survived\n      case mutationtesting.MutantStatus.NoCoverage   => MutantStatus.NoCoverage\n      case mutationtesting.MutantStatus.Timeout      => MutantStatus.Timeout\n      case mutationtesting.MutantStatus.CompileError => MutantStatus.CompileError\n      case mutationtesting.MutantStatus.RuntimeError => MutantStatus.RuntimeError\n      case mutationtesting.MutantStatus.Ignored      => MutantStatus.Ignored\n    }\n  }\n\n  implicit final class CoreLocationExtension(location: Location) {\n    implicit def asMutationElement: mutationtesting.Location =\n      mutationtesting.Location(location.start.asMutationElement, location.end.asMutationElement)\n  }\n\n  implicit final class LocationExtension(location: mutationtesting.Location) {\n    implicit def asCoreElement: Location =\n      new Location(location.start.asCoreElement, location.end.asCoreElement)\n  }\n\n  implicit final class CorePositionExtension(position: Position) {\n    implicit def asMutationElement: mutationtesting.Position =\n      mutationtesting.Position(position.line, position.column)\n  }\n\n  implicit final class PositionExtension(position: mutationtesting.Position) {\n    implicit def asCoreElement: Position = new Position(position.line, position.column)\n  }\n}\n","mutants":[{"mutatorName":"ConditionalExpression","location":{"start":{"line":48,"column":11},"end":{"line":48,"column":29}},"replacement":"true","id":"103","status":"NoCoverage"},{"mutatorName":"ConditionalExpression","location":{"start":{"line":48,"column":11},"end":{"line":48,"column":29}},"replacement":"false","id":"104","status":"NoCoverage"},{"mutatorName":"ConditionalExpression","location":{"start":{"line":57,"column":11},"end":{"line":57,"column":27}},"replacement":"true","id":"105","status":"NoCoverage"},{"mutatorName":"ConditionalExpression","location":{"start":{"line":57,"column":11},"end":{"line":57,"column":27}},"replacement":"false","id":"106","status":"NoCoverage"}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/run/TestRunner.scala":{"source":"package stryker4jvm.run\n\nimport cats.effect.{Deferred, IO, Ref, Resource}\nimport fansi.Color\nimport mutationtesting.{MutantResult, MutantStatus}\nimport stryker4jvm.config.Config\nimport stryker4jvm.core.model.{AST, MutantWithId}\nimport stryker4jvm.extensions.DurationExtensions.HumanReadableExtension\nimport stryker4jvm.extensions.MutantExtensions.ToMutantResultExtension\nimport stryker4jvm.extensions.ResourceExtensions.SelfRecreatingResource\nimport stryker4jvm.logging.FansiLogger\nimport stryker4jvm.model.InitialTestRunResult\n\nimport java.util.concurrent.TimeUnit\nimport scala.concurrent.duration.*\n\ntrait TestRunner {\n  def initialTestRun(): IO[InitialTestRunResult]\n  def runMutant(mutant: MutantWithId[AST], testNames: Seq[String]): IO[MutantResult]\n}\n\n/** Wrapping testrunners to add functionality to existing testrunners\n  */\nobject TestRunner {\n\n  def timeoutRunner(timeout: Deferred[IO, FiniteDuration], inner: Resource[IO, TestRunner])(implicit\n      config: Config,\n      log: FansiLogger\n  ): Resource[IO, TestRunner] =\n    inner.selfRecreatingResource { (testRunnerRef, releaseAndSwap) =>\n      IO {\n        new TestRunner {\n          override def runMutant(mutant: MutantWithId[AST], testNames: Seq[String]): IO[MutantResult] =\n            for {\n              runner <- testRunnerRef.get\n              time <- timeout.get\n              result <- runner\n                .runMutant(mutant, testNames)\n                .timeoutTo(\n                  time,\n                  IO(log.debug(s\"Mutant ${mutant.id} timed out over ${time.toHumanReadable}\")) *>\n                    releaseAndSwap\n                      .as(mutant.toMutantResult(MutantStatus.Timeout))\n                )\n            } yield result\n\n          override def initialTestRun(): IO[InitialTestRunResult] =\n            for {\n              runner <- testRunnerRef.get\n              (timedDuration, result) <- runner.initialTestRun().timed\n              // Use reported duration if its available, or timed duration as a backup\n              duration = result.reportedDuration.getOrElse(timedDuration)\n\n              setTimeout = calculateTimeout(duration)\n              isSet <- timeout.complete(setTimeout)\n              _ <-\n                IO.whenA(isSet) {\n                  IO(log.info(s\"Timeout set to ${setTimeout.toHumanReadable} (${Color\n                      .LightGray(s\"net ${duration.toHumanReadable}\")})\"))\n                }\n            } yield result\n\n          def calculateTimeout(netTimeMS: FiniteDuration)(implicit config: Config): FiniteDuration =\n            FiniteDuration((netTimeMS.toMillis * config.timeoutFactor).toLong, TimeUnit.MILLISECONDS) + config.timeout\n        }\n      }\n    }\n\n  def retryRunner(\n      inner: Resource[IO, TestRunner]\n  )(implicit log: FansiLogger): Resource[IO, TestRunner] =\n    inner.selfRecreatingResource { (testRunnerRef, releaseAndSwap) =>\n      IO {\n        new TestRunner {\n\n          override def runMutant(mutant: MutantWithId[AST], testNames: Seq[String]): IO[MutantResult] =\n            retryRunMutation(mutant, testNames)\n\n          def retryRunMutation(\n              mutant: MutantWithId[AST],\n              testNames: Seq[String],\n              retriesLeft: Long = 2\n          ): IO[MutantResult] = {\n            testRunnerRef.get.flatMap(_.runMutant(mutant, testNames)).handleErrorWith { _ =>\n              // On error, get a new testRunner and set it\n              IO(\n                log.debug(\n                  s\"Testrunner crashed for mutant ${mutant.id}. Starting a new one and retrying this mutant $retriesLeft more time(s)\"\n                )\n              ) *>\n                // Release old resource and make a new one, then retry the mutation\n                releaseAndSwap *>\n                (if (retriesLeft > 0) retryRunMutation(mutant, testNames, retriesLeft - 1)\n                 else IO.pure(mutant.toMutantResult(MutantStatus.RuntimeError)))\n            }\n          }\n          override def initialTestRun(): IO[InitialTestRunResult] =\n            testRunnerRef.get.flatMap(_.initialTestRun())\n        }\n      }\n    }\n\n  def maxReuseTestRunner(maxReuses: Int, inner: Resource[IO, TestRunner])(implicit\n      log: FansiLogger\n  ): Resource[IO, TestRunner] =\n    inner.selfRecreatingResource { (testRunnerRef, releaseAndSwap) =>\n      Ref[IO].of(0).map { usesRef =>\n        new TestRunner {\n          def runMutant(mutant: MutantWithId[AST], testNames: Seq[String]): IO[MutantResult] = for {\n            uses <- usesRef.getAndUpdate(_ + 1)\n            _ <-\n              // If the limit has been reached, create a new testrunner\n              IO.whenA(uses == maxReuses) {\n                IO(log.info(s\"Testrunner has run for $uses times. Restarting it...\")) *>\n                  releaseAndSwap *>\n                  usesRef.set(1)\n              }\n            runner <- testRunnerRef.get\n            result <- runner.runMutant(mutant, testNames)\n          } yield result\n\n          override def initialTestRun(): IO[InitialTestRunResult] = for {\n            _ <- usesRef.update(_ + 1)\n            runner <- testRunnerRef.get\n            result <- runner.initialTestRun()\n          } yield result\n        }\n      }\n    }\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":41,"column":32},"end":{"line":41,"column":93}},"replacement":"\"\"","id":"9","status":"Killed","testsCompleted":11},{"mutatorName":"StringLiteral","location":{"start":{"line":58,"column":31},"end":{"line":59,"column":72}},"replacement":"\"\"","id":"10","status":"Killed","testsCompleted":11},{"mutatorName":"StringLiteral","location":{"start":{"line":59,"column":34},"end":{"line":59,"column":68}},"replacement":"\"\"","id":"11","status":"Killed","testsCompleted":11},{"mutatorName":"StringLiteral","location":{"start":{"line":88,"column":19},"end":{"line":88,"column":135}},"replacement":"\"\"","id":"17","status":"Killed","testsCompleted":11},{"mutatorName":"ConditionalExpression","location":{"start":{"line":93,"column":22},"end":{"line":93,"column":37}},"replacement":"true","id":"19","status":"RuntimeError"},{"mutatorName":"ConditionalExpression","location":{"start":{"line":93,"column":22},"end":{"line":93,"column":37}},"replacement":"false","id":"20","status":"Killed","testsCompleted":11},{"mutatorName":"EqualityOperator","location":{"start":{"line":93,"column":34},"end":{"line":93,"column":35}},"replacement":">=","id":"21","status":"Killed","testsCompleted":11},{"mutatorName":"EqualityOperator","location":{"start":{"line":93,"column":34},"end":{"line":93,"column":35}},"replacement":"<","id":"22","status":"Killed","testsCompleted":11},{"mutatorName":"EqualityOperator","location":{"start":{"line":93,"column":34},"end":{"line":93,"column":35}},"replacement":"==","id":"23","status":"Killed","testsCompleted":11},{"mutatorName":"EqualityOperator","location":{"start":{"line":113,"column":29},"end":{"line":113,"column":31}},"replacement":"!=","id":"24","status":"Killed","testsCompleted":11},{"mutatorName":"StringLiteral","location":{"start":{"line":114,"column":29},"end":{"line":114,"column":84}},"replacement":"\"\"","id":"25","status":"Killed","testsCompleted":11}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/reporting/reporters/ConsoleReporter.scala":{"source":"package stryker4jvm.reporting.reporters\n\nimport cats.effect.IO\nimport fansi.{Color, EscapeAttr, Str}\nimport fs2.Pipe\nimport mutationtesting.{MutantResult, MutantStatus, Position}\nimport stryker4jvm.config.Config\nimport stryker4jvm.extensions.DurationExtensions.HumanReadableExtension\nimport stryker4jvm.extensions.NumberExtensions.RoundDecimalsExtension\nimport stryker4jvm.logging.FansiLogger\nimport stryker4jvm.reporting.{IOReporter, *}\nimport stryker4jvm.run.threshold.*\n\nimport scala.concurrent.duration.*\n\nclass ConsoleReporter()(implicit config: Config, log: FansiLogger) extends IOReporter {\n\n  override def mutantTested: Pipe[IO, MutantTestedEvent, Nothing] = in => {\n    val stream = in.zipWithIndex.map { case (l, r) => (l, r + 1) }\n    // Log the first status right away, and then the latest every 0.5 seconds\n    // 0.5 seconds is a good middle-ground between not printing too much and still feeling snappy\n    (stream.head ++ stream.tail.debounce(0.5.seconds)).evalMap { case (event, progress) =>\n      val total = event.totalMutants\n      IO(log.info(s\"Tested mutant $progress/$total (${((progress / total.toDouble) * 100).round}%)\"))\n    }.drain\n  }\n\n  override def onRunFinished(finishedRunEvent: FinishedRunEvent): IO[Unit] = IO {\n    val report = finishedRunEvent.report\n    val metrics = finishedRunEvent.metrics\n    val duration = finishedRunEvent.duration\n\n    log.info(s\"Mutation run finished! Took ${duration.toHumanReadable}\")\n    log.info(s\"Total mutants: ${Color.Cyan(metrics.totalMutants.toString())}, detected: ${Color\n        .Green(metrics.totalDetected.toString())}, undetected: ${Color.Red(metrics.totalUndetected.toString())}\")\n\n    val (detectedMutants, rest) = report.files.toSeq\n      .flatMap { case (loc, f) =>\n        f.mutants.map(m => (loc, m, f.source))\n      }\n      .partition(m => isDetected(m._2))\n    val (undetectedMutants, _) = rest partition (m => isUndetected(m._2))\n\n    if (detectedMutants.nonEmpty) log.debug(resultToString(\"Detected\", detectedMutants))\n    if (undetectedMutants.nonEmpty) log.info(resultToString(\"Undetected\", undetectedMutants))\n\n    val mutationScoreRounded = metrics.mutationScore.roundDecimals(2) match {\n      case score if score.isNaN() => \"n/a\"\n      case score                  => score.toString\n    }\n\n    def scoreString(color: EscapeAttr) = s\"Mutation score: ${color(mutationScoreRounded)}%\"\n\n    val scoreStatus = ThresholdChecker.determineScoreStatus(metrics.mutationScore)\n    scoreStatus match {\n      case _ if metrics.mutationScore.isNaN() =>\n        log.info(scoreString(Color.LightGray))\n      case SuccessStatus => log.info(scoreString(Color.Green))\n      case WarningStatus => log.warn(scoreString(Color.Yellow))\n      case DangerStatus =>\n        log.error(s\"Mutation score dangerously low!\")\n        log.error(scoreString(Color.Red))\n      case ErrorStatus =>\n        log.error(\n          s\"Mutation score below threshold! ${scoreString(Color.Red)}. Threshold: ${config.thresholds.break}%\"\n        )\n    }\n  }\n\n  private def resultToString(name: String, mutants: Seq[(String, MutantResult, String)]): Str = {\n    val mutantsStr =\n      if (mutants.nonEmpty)\n        Str.join(\n          mutants\n            .sortBy(m => m._2.id)\n            .map { case (filePath, mutant, testResult) => mutantDiff(filePath, mutant, testResult) },\n          \"\\n\"\n        )\n      else Str(\"\")\n\n    Str(s\"$name mutants:\\n\", mutantsStr)\n  }\n\n  private def mutantDiff(filePath: String, mutant: MutantResult, source: String): Str = {\n    val line = mutant.location.start.line\n    val col = mutant.location.start.column\n\n    Str.join(\n      Seq(\n        s\"${mutant.id}. [${Color.Magenta(mutant.status.toString())}] [${Color.LightGray(mutant.mutatorName)}]\",\n        Str.join(Seq(Color.Blue(filePath), Color.Yellow(line.toString()), Color.Yellow(col.toString())), \":\"),\n        Color.Red(s\"-${tabbed(findOriginal(source, mutant))}\"),\n        Color.Green(s\"+${tabbed(mutant.replacement)}\"),\n        \"\"\n      ),\n      \"\\n\"\n    )\n  }\n\n  private def tabbed(string: String) = string.linesIterator.map(\"\\t\" + _).mkString(\"\\n\")\n\n  private def findOriginal(source: String, mutant: MutantResult): String = {\n    val Position(startLinePos, startColumnPos) = mutant.location.start\n    val Position(endLinePos, endColumnPos) = mutant.location.end\n    val lines = source.linesIterator.toSeq\n    val startLine = lines(Math.max(0, startLinePos - 1)).substring(Math.max(0, startColumnPos - 1))\n    endLinePos - startLinePos match {\n      // Mutation is 1 line\n      case 0 => startLine.substring(0, endColumnPos - startColumnPos)\n      // Mutation is two lines\n      case 1 =>\n        val endLine = lines(endLinePos - 1).substring(0, endColumnPos - 1)\n        s\"$startLine\\n$endLine\"\n      // Mutation is multiple lines\n      case _ =>\n        val linesBetween = lines.slice(startLinePos, endLinePos - 1)\n        val endLine = lines(endLinePos - 1).substring(0, endColumnPos - 1)\n        (startLine +: linesBetween :+ endLine).mkString(\"\\n\")\n    }\n  }\n\n  private def isDetected(mutant: MutantResult): Boolean =\n    mutant.status == MutantStatus.Killed || mutant.status == MutantStatus.Timeout\n\n  private def isUndetected(mutant: MutantResult): Boolean =\n    mutant.status == MutantStatus.Survived || mutant.status == MutantStatus.NoCoverage\n\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":24,"column":19},"end":{"line":24,"column":100}},"replacement":"\"\"","id":"302","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":33,"column":14},"end":{"line":33,"column":72}},"replacement":"\"\"","id":"305","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":34,"column":14},"end":{"line":35,"column":113}},"replacement":"\"\"","id":"306","status":"Killed","testsCompleted":13},{"mutatorName":"ConditionalExpression","location":{"start":{"line":44,"column":9},"end":{"line":44,"column":33}},"replacement":"true","id":"307","status":"Survived","testsCompleted":13},{"mutatorName":"ConditionalExpression","location":{"start":{"line":44,"column":9},"end":{"line":44,"column":33}},"replacement":"false","id":"308","status":"Killed","testsCompleted":13},{"mutatorName":"MethodExpression","location":{"start":{"line":44,"column":9},"end":{"line":44,"column":33}},"replacement":"detectedMutants.isEmpty","id":"309","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":44,"column":60},"end":{"line":44,"column":70}},"replacement":"\"\"","id":"310","status":"Killed","testsCompleted":13},{"mutatorName":"ConditionalExpression","location":{"start":{"line":45,"column":9},"end":{"line":45,"column":35}},"replacement":"true","id":"311","status":"Survived","testsCompleted":13},{"mutatorName":"ConditionalExpression","location":{"start":{"line":45,"column":9},"end":{"line":45,"column":35}},"replacement":"false","id":"312","status":"Killed","testsCompleted":13},{"mutatorName":"MethodExpression","location":{"start":{"line":45,"column":9},"end":{"line":45,"column":35}},"replacement":"undetectedMutants.isEmpty","id":"313","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":45,"column":61},"end":{"line":45,"column":73}},"replacement":"\"\"","id":"314","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":48,"column":38},"end":{"line":48,"column":43}},"replacement":"\"\"","id":"315","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":52,"column":42},"end":{"line":52,"column":92}},"replacement":"\"\"","id":"316","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":61,"column":19},"end":{"line":61,"column":53}},"replacement":"\"\"","id":"317","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":65,"column":11},"end":{"line":65,"column":111}},"replacement":"\"\"","id":"318","status":"Killed","testsCompleted":13},{"mutatorName":"ConditionalExpression","location":{"start":{"line":72,"column":11},"end":{"line":72,"column":27}},"replacement":"true","id":"319","status":"Survived","testsCompleted":13},{"mutatorName":"ConditionalExpression","location":{"start":{"line":72,"column":11},"end":{"line":72,"column":27}},"replacement":"false","id":"320","status":"Killed","testsCompleted":13},{"mutatorName":"MethodExpression","location":{"start":{"line":72,"column":11},"end":{"line":72,"column":27}},"replacement":"mutants.isEmpty","id":"321","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":77,"column":11},"end":{"line":77,"column":15}},"replacement":"\"\"","id":"322","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":79,"column":16},"end":{"line":79,"column":18}},"replacement":"\"Stryker was here!\"","id":"323","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":81,"column":9},"end":{"line":81,"column":28}},"replacement":"\"\"","id":"325","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":90,"column":9},"end":{"line":90,"column":111}},"replacement":"\"\"","id":"330","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":91,"column":106},"end":{"line":91,"column":109}},"replacement":"\"\"","id":"331","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":92,"column":19},"end":{"line":92,"column":62}},"replacement":"\"\"","id":"332","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":93,"column":21},"end":{"line":93,"column":54}},"replacement":"\"\"","id":"333","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":94,"column":9},"end":{"line":94,"column":11}},"replacement":"\"Stryker was here!\"","id":"334","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":96,"column":7},"end":{"line":96,"column":11}},"replacement":"\"\"","id":"335","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":100,"column":65},"end":{"line":100,"column":69}},"replacement":"\"\"","id":"337","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":100,"column":84},"end":{"line":100,"column":88}},"replacement":"\"\"","id":"338","status":"Killed","testsCompleted":13},{"mutatorName":"MethodExpression","location":{"start":{"line":106,"column":27},"end":{"line":106,"column":35}},"replacement":"Math.min","id":"339","status":"Killed","testsCompleted":13},{"mutatorName":"MethodExpression","location":{"start":{"line":106,"column":68},"end":{"line":106,"column":76}},"replacement":"Math.min","id":"341","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":113,"column":9},"end":{"line":113,"column":32}},"replacement":"\"\"","id":"342","status":"Killed","testsCompleted":13},{"mutatorName":"StringLiteral","location":{"start":{"line":118,"column":57},"end":{"line":118,"column":61}},"replacement":"\"\"","id":"344","status":"Killed","testsCompleted":13},{"mutatorName":"EqualityOperator","location":{"start":{"line":123,"column":19},"end":{"line":123,"column":21}},"replacement":"!=","id":"345","status":"Killed","testsCompleted":13},{"mutatorName":"LogicalOperator","location":{"start":{"line":123,"column":42},"end":{"line":123,"column":44}},"replacement":"&&","id":"346","status":"Killed","testsCompleted":13},{"mutatorName":"EqualityOperator","location":{"start":{"line":123,"column":59},"end":{"line":123,"column":61}},"replacement":"!=","id":"347","status":"Killed","testsCompleted":13},{"mutatorName":"EqualityOperator","location":{"start":{"line":126,"column":19},"end":{"line":126,"column":21}},"replacement":"!=","id":"348","status":"Killed","testsCompleted":13},{"mutatorName":"LogicalOperator","location":{"start":{"line":126,"column":44},"end":{"line":126,"column":46}},"replacement":"&&","id":"349","status":"Killed","testsCompleted":13},{"mutatorName":"EqualityOperator","location":{"start":{"line":126,"column":61},"end":{"line":126,"column":63}},"replacement":"!=","id":"350","status":"Survived","testsCompleted":13}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/exception/UnableToFixCompilerErrorsException.scala":{"source":"package stryker4jvm.exception\n\nimport cats.data.NonEmptyList\nimport cats.syntax.foldable.*\nimport stryker4jvm.core.exception.Stryker4jvmException\nimport stryker4jvm.model.CompilerErrMsg\n\nimport scala.util.control.NoStackTrace\n\nfinal case class UnableToFixCompilerErrorsException(errs: NonEmptyList[CompilerErrMsg])\n    extends Stryker4jvmException(\n      \"Unable to remove non-compiling mutants in the mutated files. As a work-around you can exclude them in the stryker.conf. Please report this issue at https://github.com/stryker-mutator/stryker4s/issues\\n\"\n        + errs\n          .map(err => s\"${err.path}: '${err.msg}'\")\n          .mkString_(\"\\n\")\n    )\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":12,"column":7},"end":{"line":12,"column":210}},"replacement":"\"\"","id":"5","status":"Killed","testsCompleted":1},{"mutatorName":"StringLiteral","location":{"start":{"line":14,"column":23},"end":{"line":14,"column":51}},"replacement":"\"\"","id":"6","status":"Killed","testsCompleted":1},{"mutatorName":"StringLiteral","location":{"start":{"line":15,"column":22},"end":{"line":15,"column":26}},"replacement":"\"\"","id":"7","status":"Killed","testsCompleted":1}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/extensions/mutationtype/ConditionalExpression.scala":{"source":"package stryker4jvm.mutator.scala.extensions.mutationtype\n\nimport scala.meta.*\n\ncase object If {\n  def unapply(ifStatement: Term.If): Option[Term] = Some(ifStatement.cond).filterNot(_.is[Lit.Boolean])\n}\n\ncase object While {\n  def unapply(whileStatement: Term.While): Option[Term] = Some(whileStatement.expr).filterNot(_.is[Lit.Boolean])\n}\n\ncase object DoWhile {\n  def unapply(doStatement: Term.Do): Option[Term] = Some(doStatement.expr).filterNot(_.is[Lit.Boolean])\n}\n\ncase object ConditionalTrue extends ConditionalExpression {\n  override val tree: Lit.Boolean = Lit.Boolean(true)\n}\n\ncase object ConditionalFalse extends ConditionalExpression {\n  override val tree: Lit.Boolean = Lit.Boolean(false)\n}\n","mutants":[{"mutatorName":"MethodExpression","location":{"start":{"line":6,"column":53},"end":{"line":6,"column":104}},"replacement":"Some(ifStatement.cond).filter(_.is[Lit.Boolean])","id":"152","status":"Killed","testsCompleted":74},{"mutatorName":"MethodExpression","location":{"start":{"line":10,"column":59},"end":{"line":10,"column":113}},"replacement":"Some(whileStatement.expr).filter(_.is[Lit.Boolean])","id":"153","status":"Killed","testsCompleted":74},{"mutatorName":"MethodExpression","location":{"start":{"line":14,"column":53},"end":{"line":14,"column":104}},"replacement":"Some(doStatement.expr).filter(_.is[Lit.Boolean])","id":"154","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":18,"column":48},"end":{"line":18,"column":52}},"replacement":"false","id":"155","status":"Ignored"},{"mutatorName":"BooleanLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":22,"column":48},"end":{"line":22,"column":53}},"replacement":"true","id":"156","status":"Ignored"}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/ScalaAST.scala":{"source":"package stryker4jvm.mutator.scala\n\nimport stryker4jvm.core.model.AST\nimport scala.meta.Tree\n\n/** A class that is used to communicate with the rest of stryker4jvm\n  *\n  * @param value\n  *   A value of type [[scala.meta.Tree]], this value is used in the rest of the scala mutator\n  */\nclass ScalaAST(val value: Tree = null) extends AST {\n  override def syntax(): String = {\n    if (value != null) {\n      return value.syntax\n    }\n\n    \"Undefined\"\n  }\n  override def hashCode(): Int = {\n    if (value != null) {\n      return value.hashCode()\n    }\n\n    -1\n  }\n\n  /** Method to compare an object to the `value`\n    *\n    * @param obj\n    *   Can be anything, but only objects of type [[scala.meta.Tree]] and [[ScalaAST]] can be used in comparison\n    * @return\n    *   Boolean value that indicates if the given object is the same as `value`\n    */\n  override def equals(obj: Any): Boolean = {\n    if (obj == null) {\n      return false\n    }\n\n    obj match {\n      case _: Tree =>\n        obj == value\n      case ast: ScalaAST =>\n        if (ast.value != null) {\n          ast.value == value\n        } else {\n          false\n        }\n      case _ => false\n    }\n\n  }\n}\n","mutants":[{"mutatorName":"ConditionalExpression","location":{"start":{"line":13,"column":9},"end":{"line":13,"column":22}},"replacement":"true","id":"61","status":"Killed","testsCompleted":6},{"mutatorName":"ConditionalExpression","location":{"start":{"line":13,"column":9},"end":{"line":13,"column":22}},"replacement":"false","id":"62","status":"Survived","testsCompleted":6},{"mutatorName":"EqualityOperator","location":{"start":{"line":13,"column":15},"end":{"line":13,"column":17}},"replacement":"==","id":"63","status":"Killed","testsCompleted":6},{"mutatorName":"StringLiteral","location":{"start":{"line":17,"column":5},"end":{"line":17,"column":16}},"replacement":"\"\"","id":"64","status":"Killed","testsCompleted":6},{"mutatorName":"ConditionalExpression","location":{"start":{"line":20,"column":9},"end":{"line":20,"column":22}},"replacement":"true","id":"65","status":"Killed","testsCompleted":43},{"mutatorName":"ConditionalExpression","location":{"start":{"line":20,"column":9},"end":{"line":20,"column":22}},"replacement":"false","id":"66","status":"Killed","testsCompleted":43},{"mutatorName":"EqualityOperator","location":{"start":{"line":20,"column":15},"end":{"line":20,"column":17}},"replacement":"==","id":"67","status":"Killed","testsCompleted":43},{"mutatorName":"ConditionalExpression","location":{"start":{"line":35,"column":9},"end":{"line":35,"column":20}},"replacement":"true","id":"68","status":"Killed","testsCompleted":2},{"mutatorName":"ConditionalExpression","location":{"start":{"line":35,"column":9},"end":{"line":35,"column":20}},"replacement":"false","id":"69","status":"Survived","testsCompleted":10},{"mutatorName":"EqualityOperator","location":{"start":{"line":35,"column":13},"end":{"line":35,"column":15}},"replacement":"!=","id":"70","status":"Killed","testsCompleted":2},{"mutatorName":"BooleanLiteral","location":{"start":{"line":36,"column":14},"end":{"line":36,"column":19}},"replacement":"true","id":"71","status":"NoCoverage"},{"mutatorName":"EqualityOperator","location":{"start":{"line":41,"column":13},"end":{"line":41,"column":15}},"replacement":"!=","id":"72","status":"Killed","testsCompleted":10},{"mutatorName":"ConditionalExpression","location":{"start":{"line":43,"column":13},"end":{"line":43,"column":30}},"replacement":"true","id":"73","status":"Survived","testsCompleted":10},{"mutatorName":"ConditionalExpression","location":{"start":{"line":43,"column":13},"end":{"line":43,"column":30}},"replacement":"false","id":"74","status":"Killed","testsCompleted":2},{"mutatorName":"EqualityOperator","location":{"start":{"line":43,"column":23},"end":{"line":43,"column":25}},"replacement":"==","id":"75","status":"Killed","testsCompleted":2},{"mutatorName":"EqualityOperator","location":{"start":{"line":44,"column":21},"end":{"line":44,"column":23}},"replacement":"!=","id":"76","status":"Killed","testsCompleted":2},{"mutatorName":"BooleanLiteral","location":{"start":{"line":46,"column":11},"end":{"line":46,"column":16}},"replacement":"true","id":"77","status":"Killed","testsCompleted":10},{"mutatorName":"BooleanLiteral","location":{"start":{"line":48,"column":17},"end":{"line":48,"column":22}},"replacement":"true","id":"78","status":"Survived","testsCompleted":10}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/model/CompilerErrMsg.scala":{"source":"package stryker4jvm.model\n\n//This class is used to contain information about mutants that did not compile\n//It essentially exists so that we don't have to pass around the SBT specific compiler exception\nfinal case class CompilerErrMsg(msg: String, path: String, line: Integer) {\n  override def toString: String = s\"$path:L$line: '$msg'\"\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":6,"column":35},"end":{"line":6,"column":58}},"replacement":"\"\"","id":"181","status":"Killed","testsCompleted":1}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/extensions/mutationtype/StringLiteral.scala":{"source":"package stryker4jvm.mutator.scala.extensions.mutationtype\n\nimport scala.meta.{Lit, Pat, Term}\n\ncase object EmptyString extends StringLiteral[Lit.String] {\n  override val tree: Lit.String = Lit.String(\"\")\n\n  override def unapply(arg: Lit.String): Option[Lit.String] =\n    super\n      .unapply(arg)\n      .filterNot(ParentIsInterpolatedString(_))\n      .filterNot(IsXmlLiteral(_))\n}\n\ncase object StrykerWasHereString extends StringLiteral[Lit.String] {\n  override val tree: Lit.String = Lit.String(\"Stryker was here!\")\n}\n\n/** Not a mutation, just an extractor for pattern matching on empty string\n  */\ncase object NonEmptyString extends NoInvalidPlacement[Lit.String] {\n  override def unapply(arg: Lit.String): Option[Lit.String] =\n    super\n      .unapply(arg)\n      .filter(_.value.nonEmpty)\n      .filterNot(ParentIsInterpolatedString(_))\n      .filterNot(IsXmlLiteral(_))\n}\n\n/** Not a mutation, just an extractor for pattern matching on interpolated strings\n  */\ncase object StringInterpolation extends NoInvalidPlacement[Term.Interpolate] {\n  import stryker4jvm.mutator.scala.extensions.TreeExtensions.IsEqualExtension\n\n  override def unapply(arg: Term.Interpolate): Option[Term.Interpolate] =\n    super.unapply(arg).filter(_.prefix.isEqual(Term.Name(\"s\")))\n}\n\nprivate object ParentIsInterpolatedString {\n  def apply(arg: Lit.String): Boolean =\n    arg.parent match {\n      // Do not mutate interpolated strings\n      case Some(_: Term.Interpolate) => true\n      case Some(_: Pat.Interpolate)  => true\n      case _                         => false\n    }\n}\n\nprivate object IsXmlLiteral {\n  def apply(arg: Lit.String): Boolean =\n    arg.parent match {\n      // Do not mutate XML literal strings\n      case Some(Term.Xml(parts, _)) if parts.contains(arg) => true\n      case Some(Pat.Xml(parts, _)) if parts.contains(arg)  => true\n      case _                                               => false\n    }\n}\n","mutants":[{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":6,"column":46},"end":{"line":6,"column":48}},"replacement":"\"Stryker was here!\"","id":"157","status":"Ignored"},{"mutatorName":"MethodExpression","location":{"start":{"line":9,"column":5},"end":{"line":12,"column":34}},"replacement":"super.unapply(arg).filterNot(ParentIsInterpolatedString(_)).filter(IsXmlLiteral(_))","id":"158","status":"Killed","testsCompleted":74},{"mutatorName":"MethodExpression","location":{"start":{"line":9,"column":5},"end":{"line":11,"column":48}},"replacement":"super.unapply(arg).filter(ParentIsInterpolatedString(_))","id":"159","status":"Killed","testsCompleted":74},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":16,"column":46},"end":{"line":16,"column":65}},"replacement":"\"\"","id":"160","status":"Ignored"},{"mutatorName":"MethodExpression","location":{"start":{"line":23,"column":5},"end":{"line":27,"column":34}},"replacement":"super.unapply(arg).filter(_.value.nonEmpty).filterNot(ParentIsInterpolatedString(_)).filter(IsXmlLiteral(_))","id":"161","status":"Killed","testsCompleted":74},{"mutatorName":"MethodExpression","location":{"start":{"line":23,"column":5},"end":{"line":26,"column":48}},"replacement":"super.unapply(arg).filter(_.value.nonEmpty).filter(ParentIsInterpolatedString(_))","id":"162","status":"Killed","testsCompleted":74},{"mutatorName":"MethodExpression","location":{"start":{"line":23,"column":5},"end":{"line":25,"column":32}},"replacement":"super.unapply(arg).filterNot(_.value.nonEmpty)","id":"163","status":"Killed","testsCompleted":74},{"mutatorName":"MethodExpression","location":{"start":{"line":25,"column":15},"end":{"line":25,"column":31}},"replacement":"_.value.isEmpty","id":"164","status":"Killed","testsCompleted":74},{"mutatorName":"MethodExpression","location":{"start":{"line":36,"column":5},"end":{"line":36,"column":64}},"replacement":"super.unapply(arg).filterNot(_.prefix.isEqual(Term.Name(\"s\")))","id":"165","status":"Killed","testsCompleted":74},{"mutatorName":"StringLiteral","location":{"start":{"line":36,"column":58},"end":{"line":36,"column":61}},"replacement":"\"\"","id":"166","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":43,"column":41},"end":{"line":43,"column":45}},"replacement":"false","id":"167","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":44,"column":41},"end":{"line":44,"column":45}},"replacement":"false","id":"168","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":45,"column":41},"end":{"line":45,"column":46}},"replacement":"true","id":"169","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":53,"column":63},"end":{"line":53,"column":67}},"replacement":"false","id":"170","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":54,"column":63},"end":{"line":54,"column":67}},"replacement":"false","id":"171","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":55,"column":63},"end":{"line":55,"column":68}},"replacement":"true","id":"172","status":"Killed","testsCompleted":74}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/reporting/reporters/HtmlReporter.scala":{"source":"package stryker4jvm.reporting.reporters\n\nimport cats.effect.IO\nimport fs2.io.file.Path\nimport mutationtesting.MutationTestResult\nimport stryker4jvm.config.Config\nimport stryker4jvm.files.FileIO\nimport stryker4jvm.logging.FansiLogger\nimport stryker4jvm.reporting.{FinishedRunEvent, IOReporter}\n\nclass HtmlReporter(fileIO: FileIO)(implicit log: FansiLogger) extends IOReporter {\n\n  private val title = \"Stryker4jvm report\"\n  private val mutationTestElementsName = \"mutation-test-elements.js\"\n  private val htmlReportResource = s\"/elements/$mutationTestElementsName\"\n  private val reportFilename = \"report.js\"\n\n  private val indexHtml: String =\n    s\"\"\"<!DOCTYPE html>\n       |<html lang=\"en\">\n       |<head>\n       |  <meta charset=\"UTF-8\">\n       |  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n       |  <script src=\"mutation-test-elements.js\"></script>\n       |</head>\n       |<body>\n       |  <mutation-test-report-app title-postfix=\"$title\">\n       |    Your browser doesn't support <a href=\"https://caniuse.com/#search=custom%20elements\">custom elements</a>.\n       |    Please use a latest version of an evergreen browser (Firefox, Chrome, Safari, Opera, etc).\n       |  </mutation-test-report-app>\n       |  <script>\n       |    const app = document.getElementsByTagName('mutation-test-report-app').item(0);\n       |    function updateTheme() {\n       |      document.body.style.backgroundColor = app.themeBackgroundColor;\n       |    }\n       |    app.addEventListener('theme-changed', updateTheme);\n       |    updateTheme();\n       |  </script>\n       |  <script src=\"$reportFilename\"></script>\n       |</body>\n       |</html>\"\"\".stripMargin\n\n  def writeMutationTestElementsJsTo(file: Path): IO[Unit] =\n    fileIO.createAndWriteFromResource(file, htmlReportResource)\n\n  def writeIndexHtmlTo(file: Path): IO[Unit] =\n    fileIO.createAndWrite(file, indexHtml)\n\n  def writeReportJsTo(file: Path, report: MutationTestResult[Config]): IO[Unit] = {\n    import io.circe.syntax.*\n    import mutationtesting.circe.*\n    val json = report.asJson.noSpaces\n    val reportContent = s\"document.querySelector('mutation-test-report-app').report = $json\"\n    fileIO.createAndWrite(file, reportContent)\n  }\n\n  override def onRunFinished(runReport: FinishedRunEvent): IO[Unit] = {\n    val path = fs2.io.file.Path.fromNioPath(runReport.reportsLocation)\n    val mutationTestElementsLocation = path / mutationTestElementsName\n    val indexLocation = path / \"index.html\"\n    val reportLocation = path / reportFilename\n\n    val reportsWriting = writeIndexHtmlTo(indexLocation) &>\n      writeReportJsTo(reportLocation, runReport.report) &>\n      writeMutationTestElementsJsTo(mutationTestElementsLocation)\n\n    reportsWriting *>\n      IO(log.info(s\"Written HTML report to $indexLocation\"))\n  }\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":13,"column":23},"end":{"line":13,"column":43}},"replacement":"\"\"","id":"324","status":"Killed","testsCompleted":6},{"mutatorName":"StringLiteral","location":{"start":{"line":14,"column":42},"end":{"line":14,"column":69}},"replacement":"\"\"","id":"326","status":"Killed","testsCompleted":6},{"mutatorName":"StringLiteral","location":{"start":{"line":15,"column":36},"end":{"line":15,"column":74}},"replacement":"\"\"","id":"327","status":"Killed","testsCompleted":6},{"mutatorName":"StringLiteral","location":{"start":{"line":16,"column":32},"end":{"line":16,"column":43}},"replacement":"\"\"","id":"328","status":"Killed","testsCompleted":6},{"mutatorName":"StringLiteral","location":{"start":{"line":19,"column":5},"end":{"line":41,"column":19}},"replacement":"\"\"","id":"329","status":"Killed","testsCompleted":6},{"mutatorName":"StringLiteral","location":{"start":{"line":53,"column":25},"end":{"line":53,"column":93}},"replacement":"\"\"","id":"336","status":"Killed","testsCompleted":6},{"mutatorName":"StringLiteral","location":{"start":{"line":60,"column":32},"end":{"line":60,"column":44}},"replacement":"\"\"","id":"340","status":"Killed","testsCompleted":6},{"mutatorName":"StringLiteral","location":{"start":{"line":68,"column":19},"end":{"line":68,"column":59}},"replacement":"\"\"","id":"343","status":"Killed","testsCompleted":6}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/extensions/mutationtype/MutationTypes.scala":{"source":"package stryker4jvm.mutator.scala.extensions.mutationtype\n\nimport stryker4jvm.mutator.scala.extensions.TreeExtensions.IsEqualExtension\n\nimport scala.meta.*\n\n/** Base trait for mutations. Mutations can be used to pattern match on (see MutantMatcher).\n  */\nsealed trait Mutation[+T <: Tree] {\n  def mutationName: String\n}\n\nobject Mutation {\n  // List of mutations\n  val mutations: List[String] = List[String](\n    classOf[EqualityOperator].getSimpleName,\n    classOf[BooleanLiteral].getSimpleName,\n    classOf[ConditionalExpression].getSimpleName,\n    classOf[LogicalOperator].getSimpleName,\n    classOf[StringLiteral[?]].getSimpleName,\n    classOf[MethodExpression].getSimpleName,\n    classOf[RegularExpression].getSimpleName()\n  )\n}\n\n/** Base trait for substitution mutation\n  *\n  * Can implicitly be converted to the appropriate `scala.meta.Tree` by importing\n  * [[stryker4jvm.mutator.scala.extensions.ImplicitMutationConversion]]\n  *\n  * @tparam T\n  *   Has to be a subtype of Tree. This is so that the tree value and unapply methods return the appropriate type. E.G.\n  *   a False is of type `scala.meta.Lit.Boolean` instead of a standard `scala.meta.Term`\n  */\ntrait SubstitutionMutation[T <: Tree] extends Mutation[T] with NoInvalidPlacement[T] {\n  def tree: T\n\n  override def unapply(arg: T): Option[T] = {\n    Some(arg)\n      .filter(_.isEqual(tree))\n      .flatMap(super.unapply)\n  }\n}\n\ntrait EqualityOperator extends SubstitutionMutation[Term.Name] {\n  override val mutationName: String = classOf[EqualityOperator].getSimpleName\n}\n\ntrait BooleanLiteral extends SubstitutionMutation[Lit.Boolean] {\n  override val mutationName: String = classOf[BooleanLiteral].getSimpleName\n}\n\ntrait ConditionalExpression extends SubstitutionMutation[Lit.Boolean] {\n  override val mutationName: String = classOf[ConditionalExpression].getSimpleName\n}\n\ntrait LogicalOperator extends SubstitutionMutation[Term.Name] {\n  override val mutationName: String = classOf[LogicalOperator].getSimpleName\n}\n\n/** T &lt;: Term because it can be either a `Lit.String` or `Term.Interpolation`\n  */\ntrait StringLiteral[T <: Term] extends SubstitutionMutation[T] {\n  override val mutationName: String = classOf[StringLiteral[?]].getSimpleName\n}\n\n/** Base trait for method mutation\n  */\ntrait MethodExpression extends Mutation[Term] {\n\n  /** Method to be replaced or to replace\n    */\n  protected val methodName: String\n\n  override val mutationName: String = classOf[MethodExpression].getSimpleName\n\n  def apply(f: String => Term): Term = f(methodName)\n\n  def unapply(term: Term): Option[(Term, String => Term)]\n}\n\n/** Helper extractor to filter out mutants that syntactically can not be placed\n  */\nprotected trait NoInvalidPlacement[T <: Tree] {\n  def unapply(arg: T): Option[T] = {\n    Some(arg)\n      .filterNot {\n        case name: Term.Name       => name.isDefinition\n        case ParentIsTypeLiteral() => true\n        case _                     => false\n      }\n  }\n}\n\nprivate[stryker4jvm] case object ParentIsTypeLiteral {\n  def unapply(t: Tree): Boolean = {\n    t.parent.exists {\n      case Defn.Val(_, _, Some(`t`), _)       => true\n      case Defn.Var(_, _, Some(`t`), _)       => true\n      case Defn.Def(_, _, _, _, Some(`t`), _) => true\n      case Defn.Type(_, _, _, `t`)            => true\n      case p                                  => p.is[Type] || p.is[Term.ApplyType]\n    }\n  }\n}\n","mutants":[{"mutatorName":"MethodExpression","location":{"start":{"line":39,"column":5},"end":{"line":40,"column":31}},"replacement":"Some(arg).filterNot(_.isEqual(tree))","id":"186","status":"Killed","testsCompleted":74},{"mutatorName":"MethodExpression","location":{"start":{"line":86,"column":5},"end":{"line":91,"column":8}},"replacement":"Some(arg).filter({\n  case name: Term.Name =>\n    name.isDefinition\n  case ParentIsTypeLiteral() =>\n    true\n  case _ =>\n    false\n})","id":"188","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":89,"column":39},"end":{"line":89,"column":43}},"replacement":"false","id":"189","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":90,"column":39},"end":{"line":90,"column":44}},"replacement":"true","id":"190","status":"Killed","testsCompleted":74},{"mutatorName":"MethodExpression","location":{"start":{"line":97,"column":5},"end":{"line":103,"column":6}},"replacement":"t.parent.forall({\n  case Defn.Val(_, _, Some(`t`), _) =>\n    true\n  case Defn.Var(_, _, Some(`t`), _) =>\n    true\n  case Defn.Def(_, _, _, _, Some(`t`), _) =>\n    true\n  case Defn.Type(_, _, _, `t`) =>\n    true\n  case p =>\n    p.is[Type] || (p.is[Term.ApplyType])\n})","id":"191","status":"Killed","testsCompleted":92},{"mutatorName":"BooleanLiteral","location":{"start":{"line":98,"column":50},"end":{"line":98,"column":54}},"replacement":"false","id":"192","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":99,"column":50},"end":{"line":99,"column":54}},"replacement":"false","id":"193","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":100,"column":50},"end":{"line":100,"column":54}},"replacement":"false","id":"194","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":101,"column":50},"end":{"line":101,"column":54}},"replacement":"false","id":"195","status":"Killed","testsCompleted":74},{"mutatorName":"LogicalOperator","location":{"start":{"line":102,"column":61},"end":{"line":102,"column":63}},"replacement":"&&","id":"196","status":"Killed","testsCompleted":74}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/extensions/mutationtype/EqualityOperator.scala":{"source":"package stryker4jvm.mutator.scala.extensions.mutationtype\n\nimport scala.meta.Term\n\ncase object GreaterThan extends EqualityOperator {\n  override val tree: Term.Name = Term.Name(\">\")\n}\n\ncase object GreaterThanEqualTo extends EqualityOperator {\n  override val tree: Term.Name = Term.Name(\">=\")\n}\n\ncase object LesserThanEqualTo extends EqualityOperator {\n  override val tree: Term.Name = Term.Name(\"<=\")\n}\n\ncase object LesserThan extends EqualityOperator {\n  override val tree: Term.Name = Term.Name(\"<\")\n}\n\ncase object EqualTo extends EqualityOperator {\n  override val tree: Term.Name = Term.Name(\"==\")\n}\n\ncase object NotEqualTo extends EqualityOperator {\n  override val tree: Term.Name = Term.Name(\"!=\")\n}\n\ncase object TypedEqualTo extends EqualityOperator {\n  override val tree: Term.Name = Term.Name(\"===\")\n}\n\ncase object TypedNotEqualTo extends EqualityOperator {\n  override val tree: Term.Name = Term.Name(\"=!=\")\n}\n","mutants":[{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":6,"column":44},"end":{"line":6,"column":47}},"replacement":"\"\"","id":"175","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":10,"column":44},"end":{"line":10,"column":48}},"replacement":"\"\"","id":"176","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":14,"column":44},"end":{"line":14,"column":48}},"replacement":"\"\"","id":"177","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":18,"column":44},"end":{"line":18,"column":47}},"replacement":"\"\"","id":"178","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":22,"column":44},"end":{"line":22,"column":48}},"replacement":"\"\"","id":"179","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":26,"column":44},"end":{"line":26,"column":48}},"replacement":"\"\"","id":"180","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":30,"column":44},"end":{"line":30,"column":49}},"replacement":"\"\"","id":"181","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":34,"column":44},"end":{"line":34,"column":49}},"replacement":"\"\"","id":"182","status":"Ignored"}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/ScalaCollector.scala":{"source":"package stryker4jvm.mutator.scala\n\nimport stryker4jvm.core.model.Collector\nimport stryker4jvm.core.model.CollectedMutants\nimport stryker4jvm.core.model.CollectedMutants.IgnoredMutation\n\nimport scala.meta.Tree\n\nimport stryker4jvm.core.model.MutatedCode\nimport scala.collection.mutable.Map\n\nimport scala.collection.JavaConverters.*\nimport java.util as ju\nimport stryker4jvm.core.logging.Logger\n\nimport stryker4jvm.mutator.scala.extensions.TreeExtensions.*\n\n/** Class that is used to collect mutants in an AST\n  *\n  * @param traverser\n  *   Used to traverse through an AST\n  * @param matcher\n  *   Used to check if a mutation can be placed on a given PlaceableTree\n  * @param log\n  */\nclass ScalaCollector(\n    val traverser: Traverser,\n    val matcher: MutantMatcher\n)(implicit log: Logger)\n    extends Collector[ScalaAST] {\n\n  /** The actual method that collects the mutants\n    *\n    * @param ast\n    *   A ScalaAST of the input file (generated by [[stryker4jvm.mutator.scala.ScalaParser]])\n    * @return\n    *   All the collected mutants in the given AST (also includes excluded mutants)\n    */\n  override def collect(ast: ScalaAST): CollectedMutants[ScalaAST] = {\n    val tree = ast.value;\n\n    if (tree == null) {\n      log.error(\"Tree is null\");\n      return null;\n    }\n\n    // PartialFunction to check if the currently-visiting tree node is a node where we can place mutants\n    val canPlaceF: PartialFunction[Tree, PlaceableTree] = Function.unlift(traverser.canPlace).andThen(PlaceableTree(_))\n\n    // PartialFunction that _sometimes_ matches and returns the mutations at a PlaceableTree `NonEmptyList[Mutant]`\n    val onEnterF = matcher.allMatchers.andThen(f => (p: PlaceableTree) => p -> f(p))\n\n    // Walk through the tree and create a Map of PlaceableTree and Mutants\n    val collected: List[(PlaceableTree, Either[Vector[IgnoredMutation[ScalaAST]], Vector[MutatedCode[ScalaAST]]])] =\n      tree.collectWithContext(canPlaceF)(onEnterF)\n\n    // Get mutations and ignoredmutations in correct format to return\n    var ignoredMutations: Vector[IgnoredMutation[ScalaAST]] = Vector()\n    var mutations = Map[ScalaAST, ju.List[MutatedCode[ScalaAST]]]()\n\n    for (col <- collected) {\n      val placeableTree = col._1\n      col._2 match {\n        case Left(value) => ignoredMutations = ignoredMutations ++ value\n        case Right(mutants) =>\n          val ast = new ScalaAST(value = placeableTree.tree);\n\n          if (mutations.contains(ast)) {\n            var muts = mutations.get(ast).get.asScala.toVector;\n            muts ++= mutants;\n\n            mutations = mutations + (ast -> muts.asJava)\n          } else {\n            mutations = mutations + (ast -> mutants.asJava)\n          }\n      }\n    }\n\n    new CollectedMutants[ScalaAST](ignoredMutations.asJava, mutations.asJava)\n  }\n\n}\n","mutants":[{"mutatorName":"ConditionalExpression","location":{"start":{"line":42,"column":9},"end":{"line":42,"column":21}},"replacement":"true","id":"44","status":"Killed","testsCompleted":35},{"mutatorName":"ConditionalExpression","location":{"start":{"line":42,"column":9},"end":{"line":42,"column":21}},"replacement":"false","id":"46","status":"Survived","testsCompleted":37},{"mutatorName":"EqualityOperator","location":{"start":{"line":42,"column":14},"end":{"line":42,"column":16}},"replacement":"!=","id":"47","status":"Killed","testsCompleted":35},{"mutatorName":"StringLiteral","location":{"start":{"line":43,"column":17},"end":{"line":43,"column":31}},"replacement":"\"\"","id":"51","status":"NoCoverage"},{"mutatorName":"ConditionalExpression","location":{"start":{"line":68,"column":15},"end":{"line":68,"column":38}},"replacement":"true","id":"59","status":"Killed","testsCompleted":35},{"mutatorName":"ConditionalExpression","location":{"start":{"line":68,"column":15},"end":{"line":68,"column":38}},"replacement":"false","id":"60","status":"Survived","testsCompleted":37}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/ScalaParser.scala":{"source":"package stryker4jvm.mutator.scala\n\nimport scala.meta.{dialects, Dialect, Parsed, Source}\nimport scala.meta.parsers.XtensionParseInputLike\nimport stryker4jvm.core.model.Parser\n\nimport java.nio\n\n/** Class used to parse (scala) files into a ScalaAST\n  */\nclass ScalaParser(scalaDialect: Dialect) extends Parser[ScalaAST] {\n\n  /** Method used to parse a file (via a path) to a ScalaAST\n    *\n    * @param file\n    *   The path to a scala file, which we want to parse\n    * @return\n    *   A ScalaAST if the file was successfully parsed, otherwise we throw an Exception\n    */\n  override def parse(file: nio.file.Path): ScalaAST = {\n    implicit val dialect: Dialect = scalaDialect\n\n    val parsed = file.parse[Source]\n\n    parsed match {\n      case _: Parsed.Error => throw new Exception(\"Cannot parse\")\n      case s =>\n        val ret = new ScalaAST(value = s.get)\n        return ret\n    }\n  }\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":26,"column":51},"end":{"line":26,"column":65}},"replacement":"\"\"","id":"58","status":"Survived","testsCompleted":3}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/ScalaInstrumenter.scala":{"source":"package stryker4jvm.mutator.scala\n\nimport stryker4jvm.core.model.Instrumenter\n\nimport java.util as ju\nimport scala.collection.JavaConverters.*\n\nimport cats.data.{NonEmptyList, NonEmptyVector}\nimport cats.syntax.all.*\nimport stryker4jvm.mutator.scala.extensions.TreeExtensions.TransformOnceExtension\nimport stryker4jvm.core.model.MutantWithId\n\nimport scala.meta.*\nimport scala.util.control.NonFatal\nimport scala.util.{Failure, Success}\n\nclass ScalaInstrumenter(options: ScalaInstrumenterOptions) extends Instrumenter[ScalaAST] {\n\n  /** Method that places mutations in a given AST\n    *\n    * @param source\n    *   The input AST\n    * @param mutations\n    *   All the mutations found in the input AST, which are used in the returned AST\n    * @return\n    *   AST with all mutations placed (using match statements)\n    */\n  override def instrument(source: ScalaAST, mutations: ju.Map[ScalaAST, ju.List[MutantWithId[ScalaAST]]]): ScalaAST = {\n    if (source.value == null) {\n      return new ScalaAST // TODO\n    }\n\n    val newTree = source.value\n      .transformOnce {\n        Function.unlift { originalTree =>\n          val p = new ScalaAST(value = originalTree)\n\n          // Get all mutations for a given tree\n          val mutGet = mutations.get(p)\n\n          if (mutGet != null) {\n            val mut: Vector[MutantWithId[ScalaAST]] = mutGet.asScala.toVector\n\n            val mutableCases = mut.map(mutantToCase)\n            val maybeNonemptyList = NonEmptyList.fromList(mut.map(_.id).toList);\n\n            var nonEmptylist: NonEmptyList[Int] = NonEmptyList.one(0);\n            maybeNonemptyList match {\n              case Some(value) => nonEmptylist = value\n              case None        =>\n            };\n\n            val default = defaultCase(p, nonEmptylist)\n            val cases = mutableCases :+ default\n\n            // Build the match statement and cast to a Tree\n            try Some(buildMatch(cases.toNev.get).asInstanceOf[Tree])\n            catch {\n              case NonFatal(_) => throw new Exception\n            }\n          } else {\n            None\n          }\n        }\n      } match {\n      case Success(tree) => tree\n      case Failure(e)    => throw e\n    }\n\n    new ScalaAST(value = newTree)\n  }\n\n  def mutantToCase(mutant: MutantWithId[ScalaAST]): Case = {\n    val newTree = mutant.mutatedCode.mutatedStatement.value.asInstanceOf[Term]\n\n    buildCase(newTree, options.pattern(mutant.id))\n  }\n\n  def defaultCase(scalaAST: ScalaAST, mutantIds: NonEmptyList[Int]): Case =\n    p\"case _ if ${options.condition.mapApply(mutantIds)} => ${scalaAST.value.asInstanceOf[Term]}\"\n\n  def buildCase(expression: Term, pattern: Pat): Case = p\"case $pattern => $expression\"\n\n  def buildMatch(cases: NonEmptyVector[Case]): Term.Match =\n    q\"(${options.mutationContext} match { ..case ${cases.toList} })\"\n\n}\n","mutants":[{"mutatorName":"ConditionalExpression","location":{"start":{"line":29,"column":9},"end":{"line":29,"column":29}},"replacement":"true","id":"79","status":"Killed","testsCompleted":2},{"mutatorName":"ConditionalExpression","location":{"start":{"line":29,"column":9},"end":{"line":29,"column":29}},"replacement":"false","id":"80","status":"Survived","testsCompleted":2},{"mutatorName":"EqualityOperator","location":{"start":{"line":29,"column":22},"end":{"line":29,"column":24}},"replacement":"!=","id":"81","status":"Killed","testsCompleted":2},{"mutatorName":"ConditionalExpression","location":{"start":{"line":41,"column":15},"end":{"line":41,"column":29}},"replacement":"true","id":"82","status":"Killed","testsCompleted":2},{"mutatorName":"ConditionalExpression","location":{"start":{"line":41,"column":15},"end":{"line":41,"column":29}},"replacement":"false","id":"83","status":"Killed","testsCompleted":2},{"mutatorName":"EqualityOperator","location":{"start":{"line":41,"column":22},"end":{"line":41,"column":24}},"replacement":"==","id":"84","status":"Killed","testsCompleted":2}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/files/ConfigFilesResolver.scala":{"source":"package stryker4jvm.files\n\nimport cats.effect.IO\nimport fs2.Stream\nimport fs2.io.file.{Files, Path}\nimport stryker4jvm.config.Config\nimport stryker4jvm.files.Glob.glob\nimport stryker4jvm.logging.FansiLogger\nimport stryker4jvm.run.process.{Command, ProcessRunner}\n\nclass ConfigFilesResolver(processRunner: ProcessRunner)(implicit config: Config, log: FansiLogger)\n    extends FilesFileResolver {\n\n  /** Collect all files that are needed to be copied over to the Stryker4s-tmp folder.\n    *\n    *   - Option 1: Copy every file that is listed by the 'files' config setting.\n    *   - Option 2: Copy every file that is listed by git.\n    *   - Option 3: Copy every file in the 'baseDir' excluding target folders.\n    */\n  override def files: Stream[IO, Path] =\n    (listFilesBasedOnConfiguration() orElse listFilesBasedOnGit() getOrElse listAllFiles())\n      .evalFilterNot(Files[IO].isDirectory)\n      .evalFilter(Files[IO].exists)\n\n  /** List all files based on `git ls-files` command.\n    */\n  private def listFilesBasedOnGit(): Option[Stream[IO, Path]] =\n    processRunner(\n      Command(\"git ls-files\", \"--others --exclude-standard --cached\"),\n      config.baseDir\n    ).toOption\n      .map(_.map(config.baseDir / _).distinct)\n      .map(Stream.emits)\n\n  /** List all files from the base directory specified in the Stryker4s basedir config key.\n    */\n  private def listAllFiles(): Stream[IO, Path] = {\n    log.warn(\"No 'files' specified and not a git repository.\")\n    log.warn(\"Falling back to copying everything except the 'target/' folder(s)\")\n\n    Files[IO].walk(config.baseDir)\n  }\n\n  /** List all files based on the 'files' configuration key from stryker4s.conf.\n    */\n  private def listFilesBasedOnConfiguration(): Option[Stream[IO, Path]] =\n    if (config.files.isEmpty) None else Some(glob(config.baseDir, config.files))\n\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":29,"column":15},"end":{"line":29,"column":29}},"replacement":"\"\"","id":"167","status":"Killed","testsCompleted":1},{"mutatorName":"StringLiteral","location":{"start":{"line":29,"column":31},"end":{"line":29,"column":69}},"replacement":"\"\"","id":"168","status":"Killed","testsCompleted":7},{"mutatorName":"StringLiteral","location":{"start":{"line":38,"column":14},"end":{"line":38,"column":62}},"replacement":"\"\"","id":"169","status":"Killed","testsCompleted":6},{"mutatorName":"StringLiteral","location":{"start":{"line":39,"column":14},"end":{"line":39,"column":81}},"replacement":"\"\"","id":"170","status":"Killed","testsCompleted":6},{"mutatorName":"ConditionalExpression","location":{"start":{"line":47,"column":9},"end":{"line":47,"column":29}},"replacement":"true","id":"171","status":"Killed","testsCompleted":7},{"mutatorName":"ConditionalExpression","location":{"start":{"line":47,"column":9},"end":{"line":47,"column":29}},"replacement":"false","id":"172","status":"Killed","testsCompleted":7},{"mutatorName":"MethodExpression","location":{"start":{"line":47,"column":9},"end":{"line":47,"column":29}},"replacement":"config.files.nonEmpty","id":"173","status":"Killed","testsCompleted":7}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/ScalaInstrumenterOptions.scala":{"source":"package stryker4jvm.mutator.scala\n\nimport scala.meta.*\nimport cats.data.NonEmptyList\nimport ActiveMutationContext.ActiveMutationContext\nimport stryker4jvm.core.model.InstrumenterOptions\nimport stryker4jvm.core.model.InstrumenterOptions.SysProp\nimport stryker4jvm.core.model.InstrumenterOptions.EnvVar\nimport stryker4jvm.core.model.InstrumenterOptions.TestRunner\n\nobject ActiveMutationContext {\n  type ActiveMutationContext = Term\n\n  lazy val envVar: ActiveMutationContext = sysContext(q\"env\")\n\n  lazy val sysProps: ActiveMutationContext = sysContext(q\"props\")\n\n  lazy val testRunner: ActiveMutationContext = q\"_root_.stryker4jvm.activeMutation\"\n\n  private def sysContext(c: Term.Name): Term.Apply = q\"_root_.scala.sys.$c.get(${Lit.String(\"ACTIVE_MUTATION\")})\"\n}\n\nfinal case class ScalaInstrumenterOptions private (\n    mutationContext: ActiveMutationContext,\n    pattern: Int => Pat,\n    condition: Option[(NonEmptyList[Int]) => Term]\n)\n\nobject ScalaInstrumenterOptions {\n\n  def fromJavaOptions(instrumenterOptions: InstrumenterOptions) = {\n    instrumenterOptions match {\n      case SysProp    => sysContext(ActiveMutationContext.sysProps)\n      case EnvVar     => sysContext(ActiveMutationContext.envVar)\n      case TestRunner => testRunner\n    }\n  }\n\n  def sysContext(context: ActiveMutationContext) =\n    ScalaInstrumenterOptions(context, pattern = i => p\"Some(${Lit.String(i.toString())})\", None)\n\n  def testRunner = ScalaInstrumenterOptions(\n    ActiveMutationContext.testRunner,\n    pattern = i => p\"$i\",\n    condition = Some(ids => q\"_root_.stryker4jvm.coverage.coverMutant(..${ids.map(Lit.Int(_)).toList})\")\n  )\n}\n","mutants":[{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":20,"column":93},"end":{"line":20,"column":110}},"replacement":"\"\"","id":"0","status":"Ignored"}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/extensions/Stryker4jvmCoreConversions.scala":{"source":"package stryker4jvm.extensions\n\nimport stryker4jvm.config.Config\nimport stryker4jvm.core.config.LanguageMutatorConfig\nimport stryker4jvm.core.model.elements.{Location, MutantResult, MutantStatus, Position}\n\nimport scala.collection.JavaConverters.*\nimport java.util.Optional\nimport scala.collection.convert.ImplicitConversions.`collection AsScalaIterable`\n\nobject Stryker4jvmCoreConversions {\n  implicit final class CoreMutantResultExtension(result: MutantResult) {\n    def asMutationElement: mutationtesting.MutantResult = {\n      mutationtesting.MutantResult(\n        result.id,\n        result.mutatorName,\n        result.replacement,\n        result.location.asMutationElement,\n        result.mutantStatus.asMutationElement,\n        result.statusReason.asScala,\n        result.description.asScala,\n        result.coveredBy.asScala.map(_.toSeq),\n        result.killedBy.asScala.map(_.toSeq),\n        result.testsCompleted.asScala.map(_.intValue()),\n        result.isStatic.asScala.map(_.booleanValue())\n      )\n    }\n  }\n\n  implicit final class MutantResultExtension(result: mutationtesting.MutantResult) {\n    def asCoreElement: MutantResult = {\n      new MutantResult(\n        result.id,\n        result.mutatorName,\n        result.replacement,\n        result.location.asCoreElement,\n        result.status.asCoreElement,\n        result.statusReason.orNull,\n        result.description.orNull,\n        result.coveredBy.map(seqAsJavaList).orNull,\n        result.killedBy.map(seqAsJavaList).orNull,\n        result.testsCompleted.map(Integer.valueOf).orNull,\n        result.static.map(Boolean.box).orNull\n      )\n    }\n  }\n\n  implicit final class JavaOptionalExtension[A](optional: Optional[A]) {\n    def asScala: Option[A] = {\n      if (optional.isPresent)\n        Option(optional.get())\n      else\n        Option.empty\n    }\n  }\n\n  implicit final class ScalaOptionalExtension[A](option: Option[A]) {\n    def asJava: Optional[A] = {\n      if (option.isDefined)\n        Optional.of(option.get)\n      else\n        Optional.empty()\n    }\n  }\n\n  implicit final class CoreMutantStatusExtension(status: MutantStatus) {\n    implicit def asMutationElement: mutationtesting.MutantStatus = {\n      status match {\n        case MutantStatus.Killed       => mutationtesting.MutantStatus.Killed\n        case MutantStatus.Survived     => mutationtesting.MutantStatus.Survived\n        case MutantStatus.NoCoverage   => mutationtesting.MutantStatus.NoCoverage\n        case MutantStatus.Timeout      => mutationtesting.MutantStatus.Timeout\n        case MutantStatus.CompileError => mutationtesting.MutantStatus.CompileError\n        case MutantStatus.RuntimeError => mutationtesting.MutantStatus.RuntimeError\n        case MutantStatus.Ignored      => mutationtesting.MutantStatus.Ignored\n      }\n    }\n  }\n\n  implicit final class MutantStatusExtension(status: mutationtesting.MutantStatus) {\n    implicit def asCoreElement: MutantStatus = status match {\n      case mutationtesting.MutantStatus.Killed       => MutantStatus.Killed\n      case mutationtesting.MutantStatus.Survived     => MutantStatus.Survived\n      case mutationtesting.MutantStatus.NoCoverage   => MutantStatus.NoCoverage\n      case mutationtesting.MutantStatus.Timeout      => MutantStatus.Timeout\n      case mutationtesting.MutantStatus.CompileError => MutantStatus.CompileError\n      case mutationtesting.MutantStatus.RuntimeError => MutantStatus.RuntimeError\n      case mutationtesting.MutantStatus.Ignored      => MutantStatus.Ignored\n    }\n  }\n\n  implicit final class CoreLocationExtension(location: Location) {\n    implicit def asMutationElement: mutationtesting.Location =\n      mutationtesting.Location(location.start.asMutationElement, location.end.asMutationElement)\n  }\n\n  implicit final class LocationExtension(location: mutationtesting.Location) {\n    implicit def asCoreElement: Location =\n      new Location(location.start.asCoreElement, location.end.asCoreElement)\n  }\n\n  implicit final class CorePositionExtension(position: Position) {\n    implicit def asMutationElement: mutationtesting.Position =\n      mutationtesting.Position(position.line, position.column)\n  }\n\n  implicit final class PositionExtension(position: mutationtesting.Position) {\n    implicit def asCoreElement: Position = new Position(position.line, position.column)\n  }\n}\n","mutants":[{"mutatorName":"ConditionalExpression","location":{"start":{"line":50,"column":11},"end":{"line":50,"column":29}},"replacement":"true","id":"182","status":"Killed","testsCompleted":7},{"mutatorName":"ConditionalExpression","location":{"start":{"line":50,"column":11},"end":{"line":50,"column":29}},"replacement":"false","id":"183","status":"Survived","testsCompleted":7},{"mutatorName":"ConditionalExpression","location":{"start":{"line":59,"column":11},"end":{"line":59,"column":27}},"replacement":"true","id":"184","status":"NoCoverage"},{"mutatorName":"ConditionalExpression","location":{"start":{"line":59,"column":11},"end":{"line":59,"column":27}},"replacement":"false","id":"185","status":"NoCoverage"}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/extensions/TreeExtensions.scala":{"source":"package stryker4jvm.mutator.scala.extensions\n\nimport cats.Eval\nimport cats.data.OptionT\nimport cats.syntax.option.*\nimport mutationtesting.Location\nimport stryker4jvm.core.model.elements\nimport weaponregex.model.Location as RegexLocation\n\nimport scala.annotation.tailrec\nimport scala.meta.*\nimport scala.meta.transversers.SimpleTraverser\nimport scala.reflect.ClassTag\nimport scala.util.Try\n\nobject TreeExtensions {\n  @tailrec\n  private def mapParent[T <: Tree, U](tree: Tree, ifFound: T => U, notFound: => U)(implicit classTag: ClassTag[T]): U =\n    tree.parent match {\n      case Some(value: T)   => ifFound(value)\n      case Some(otherValue) => mapParent(otherValue, ifFound, notFound)\n      case _                => notFound\n    }\n\n  implicit final class TopStatementExtension(val thisTerm: Term) extends AnyVal {\n\n    /** Returns the statement this tree is part of. Recursively going up the tree until a full statement is found.\n      */\n    @tailrec\n    final def topStatement(): Term =\n      thisTerm match {\n        case ParentIsPatternMatch(parent) => parent.topStatement()\n        case ParentIsFullStatement()      => thisTerm\n        case ParentIsTerm(parent)         => parent.topStatement()\n        case _                            => thisTerm\n      }\n  }\n\n  /** Extractor object to check if the [[scala.meta.Term]] part of a pattern match (but not in the body of the pattern\n    * match)\n    */\n  private object ParentIsPatternMatch {\n\n    /** Go up the tree, until a Case is found (except for try-catches), then go up until a `Term` is found\n      */\n    final def unapply(term: Term): Option[Term] =\n      term\n        .findParent[Case]\n        .filterNot(caze => caze.parent.collect { case t: Term.Try => t }.exists(_.catchp.contains(caze)))\n        .flatMap(_.findParent[Term])\n\n  }\n\n  /** Extractor object to check if the direct parent of the [[scala.meta.Term]] is a 'full statement'\n    */\n  private object ParentIsFullStatement {\n    final def unapply(term: Term): Boolean =\n      term.parent exists {\n        case _: Term.Assign                                   => true\n        case _: Defn                                          => true\n        case p if p.parent.exists(_.isInstanceOf[Term.Apply]) => false\n        case _: Term.Block                                    => true\n        case _: Term.If                                       => true\n        case _: Term.ForYield                                 => true\n        case _                                                => false\n      }\n  }\n\n  private object ParentIsTerm {\n    final def unapply(term: Term): Option[Term] =\n      term.parent collect { case parent: Term =>\n        parent\n      }\n  }\n\n  implicit final class FindExtension(val thisTree: Tree) extends AnyVal {\n\n    /** Searches for the given statement in the tree\n      *\n      * @param toFind\n      *   Statement to find\n      * @return\n      *   A <code>Some(Tree)</code> if the statement has been found, otherwise None\n      */\n    final def find[T <: Tree](toFind: T)(implicit classTag: ClassTag[T]): Option[T] =\n      thisTree.collectFirst {\n        case found: T if found.isEqual(toFind) => found\n      }\n\n    final def contains[T <: Tree](toFind: T)(implicit classTag: ClassTag[T]): Boolean =\n      thisTree\n        .collectFirst {\n          case found: T if found.isEqual(toFind) => true\n        }\n        .getOrElse(false)\n\n    final def findParent[T <: Tree](implicit classTag: ClassTag[T]): Option[T] =\n      mapParent[T, Option[T]](thisTree, Some(_), None)\n  }\n\n  implicit final class TransformOnceExtension(val thisTree: Tree) extends AnyVal {\n\n    /** The normal <code>Tree#transform</code> recursively transforms the tree each time a transformation is applied.\n      * This causes a StackOverflowError when the transformation that is searched for is also present in the newly\n      * transformed tree.\n      *\n      * This function does not recursively go into the transformed tree\n      */\n    final def transformOnce(fn: PartialFunction[Tree, Tree]): Try[Tree] = {\n      Try {\n        val onceTransformer = new OnceTransformer(fn)\n        onceTransformer(thisTree)\n      }\n    }\n\n    /** Tries to transform a tree exactly once, returning None if the transformation was never applied\n      */\n    final def transformExactlyOnce(fn: PartialFunction[Tree, Tree]): Option[Tree] = {\n      var isTransformed = false\n      val checkFn = fn.andThen { t =>\n        isTransformed = true\n        t\n      }\n      val onceTransformer = new OnceTransformer(checkFn)\n      val result = onceTransformer(thisTree)\n\n      if (isTransformed) result.some\n      else None\n    }\n  }\n\n  private class OnceTransformer(fn: PartialFunction[Tree, Tree]) extends Transformer {\n    override def apply(tree: Tree): Tree = {\n      val supered = super.apply(tree)\n      fn.applyOrElse(supered, identity[Tree])\n    }\n  }\n\n  implicit final class TreeIsInExtension(val thisTree: Tree) extends AnyVal {\n\n    /** Returns if a tree is contained in a tree of type `[T]`. Recursively going up the tree until an annotation is\n      * found.\n      */\n    final def isIn[T <: Tree](implicit classTag: ClassTag[T]): Boolean =\n      mapParent[T, Boolean](thisTree, _ => true, false)\n  }\n\n  implicit final class GetMods(val tree: Tree) extends AnyVal {\n    final def getMods: List[Mod] =\n      tree match {\n        case mc: Defn.Class  => mc.mods\n        case mc: Defn.Trait  => mc.mods\n        case mc: Defn.Object => mc.mods\n        case mc: Defn.Def    => mc.mods\n        case mc: Defn.Val    => mc.mods\n        case mc: Defn.Var    => mc.mods\n        case mc: Defn.Type   => mc.mods\n        case mc: Term.Param  => mc.mods\n        case mc: Decl.Def    => mc.mods\n        case mc: Decl.Var    => mc.mods\n        case mc: Decl.Val    => mc.mods\n        case mc: Decl.Type   => mc.mods\n        case _               => Nil\n      }\n\n  }\n\n  implicit final class IsEqualExtension(val thisTree: Tree) extends AnyVal {\n\n    /** Structural equality for Trees\n      */\n    final def isEqual(other: Tree): Boolean = thisTree == other || thisTree.structure == other.structure\n  }\n\n  implicit final class CollectFirstExtension(tree: Tree) {\n    final def collectFirst[T](pf: PartialFunction[Tree, T]): Option[T] = {\n      var result = Option.empty[T]\n      val fn = pf.lift\n      object traverser extends SimpleTraverser {\n        override def apply(t: Tree): Unit = {\n          result = if (result.isEmpty) fn(t).orElse(result) else result\n          super.apply(t)\n        }\n      }\n      traverser(tree)\n      result\n    }\n  }\n\n  implicit final class CollectWithContextExtension(val tree: Tree) extends AnyVal {\n\n    /** Scalameta collector that collects on a PartialFunction, but can build up a 'context' object that is passed to\n      * each node\n      */\n    final def collectWithContext[T, C](\n        buildContext: PartialFunction[Tree, C]\n    )(collectFn: PartialFunction[Tree, C => T]): List[T] = {\n      val buf = scala.collection.mutable.ListBuffer[T]()\n      val collectFnLifted = collectFn.lift\n      val buildContextLifted = buildContext.andThen(c => Eval.now(c.some))\n\n      def traverse(tree: Tree, context: Eval[Option[C]]): Unit = {\n        // Either match on the context of the currently-visiting tree, or go looking upwards for one (that's what the context param does)\n        val newContext = Eval.defer(buildContextLifted.applyOrElse(tree, (_: Tree) => context))\n\n        val findAndCollect = for {\n          collectTreeFn <- OptionT.fromOption[Eval](collectFnLifted(tree))\n          contextForTree <- OptionT(newContext)\n        } yield buf += collectTreeFn(contextForTree)\n        findAndCollect.value.value\n\n        tree.children.foreach(child => traverse(child, newContext))\n      }\n\n      // Traverse the tree, starting with an empty context\n      traverse(tree, Eval.now(None))\n      buf.toList\n    }\n\n  }\n\n  implicit final class StrykerPositionExtension(val pos: mutationtesting.Position) {\n    def asJvmCore: stryker4jvm.core.model.elements.Position = {\n      new elements.Position(pos.line, pos.column)\n    }\n  }\n\n  implicit final class LocationExtension(val location: Location) extends AnyVal {\n    def asJvmCore: stryker4jvm.core.model.elements.Location = {\n      new elements.Location(location.start.asJvmCore, location.end.asJvmCore)\n    }\n  }\n\n  implicit final class PositionExtension(val pos: Position) extends AnyVal {\n\n    /** Map a `scala.meta.Position` to a `mutationtesting.Location`\n      */\n    def toLocation: Location = Location(\n      start = mutationtesting.Position(line = pos.startLine + 1, column = pos.startColumn + 1),\n      end = mutationtesting.Position(line = pos.endLine + 1, column = pos.endColumn + 1)\n    )\n  }\n  implicit final class RegexLocationExtension(val pos: RegexLocation) extends AnyVal {\n\n    /** Map a `weaponregex.model.Location` to a `mutationtesting.Location`\n      */\n    def toLocation(offset: Location): Location = Location(\n      start = mutationtesting\n        .Position(line = pos.start.line + offset.start.line, column = pos.start.column + offset.start.column),\n      end = mutationtesting.Position(line = pos.end.line + offset.end.line, column = pos.end.column + offset.end.column)\n    )\n  }\n}\n","mutants":[{"mutatorName":"MethodExpression","location":{"start":{"line":47,"column":7},"end":{"line":49,"column":106}},"replacement":"term.findParent[Case].filter(caze => caze.parent.collect({\n  case t: Term.Try => t\n}).exists(_.catchp.contains(caze)))","id":"125","status":"NoCoverage"},{"mutatorName":"MethodExpression","location":{"start":{"line":49,"column":28},"end":{"line":49,"column":105}},"replacement":"caze.parent.collect({\n  case t: Term.Try => t\n}).forall(_.catchp.contains(caze))","id":"126","status":"NoCoverage"},{"mutatorName":"MethodExpression","location":{"start":{"line":58,"column":7},"end":{"line":66,"column":8}},"replacement":"term.parent forall ({\n  case _: Term.Assign => true\n  case _: Defn => true\n  case p if p.parent.exists(_.isInstanceOf[Term.Apply]) => false\n  case _: Term.Block => true\n  case _: Term.If => true\n  case _: Term.ForYield => true\n  case _ => false\n})","id":"127","status":"NoCoverage"},{"mutatorName":"BooleanLiteral","location":{"start":{"line":59,"column":66},"end":{"line":59,"column":70}},"replacement":"false","id":"128","status":"NoCoverage"},{"mutatorName":"BooleanLiteral","location":{"start":{"line":60,"column":66},"end":{"line":60,"column":70}},"replacement":"false","id":"129","status":"NoCoverage"},{"mutatorName":"MethodExpression","location":{"start":{"line":61,"column":19},"end":{"line":61,"column":62}},"replacement":"p.parent.forall(_.isInstanceOf[Term.Apply])","id":"130","status":"NoCoverage"},{"mutatorName":"BooleanLiteral","location":{"start":{"line":61,"column":66},"end":{"line":61,"column":71}},"replacement":"true","id":"131","status":"NoCoverage"},{"mutatorName":"BooleanLiteral","location":{"start":{"line":62,"column":66},"end":{"line":62,"column":70}},"replacement":"false","id":"132","status":"NoCoverage"},{"mutatorName":"BooleanLiteral","location":{"start":{"line":63,"column":66},"end":{"line":63,"column":70}},"replacement":"false","id":"133","status":"NoCoverage"},{"mutatorName":"BooleanLiteral","location":{"start":{"line":64,"column":66},"end":{"line":64,"column":70}},"replacement":"false","id":"134","status":"NoCoverage"},{"mutatorName":"BooleanLiteral","location":{"start":{"line":65,"column":66},"end":{"line":65,"column":71}},"replacement":"true","id":"135","status":"NoCoverage"},{"mutatorName":"BooleanLiteral","location":{"start":{"line":93,"column":53},"end":{"line":93,"column":57}},"replacement":"false","id":"136","status":"Killed","testsCompleted":3},{"mutatorName":"BooleanLiteral","location":{"start":{"line":95,"column":20},"end":{"line":95,"column":25}},"replacement":"true","id":"137","status":"Killed","testsCompleted":3},{"mutatorName":"BooleanLiteral","location":{"start":{"line":119,"column":27},"end":{"line":119,"column":32}},"replacement":"true","id":"138","status":"Survived","testsCompleted":111},{"mutatorName":"BooleanLiteral","location":{"start":{"line":121,"column":25},"end":{"line":121,"column":29}},"replacement":"false","id":"139","status":"Killed","testsCompleted":74},{"mutatorName":"ConditionalExpression","location":{"start":{"line":127,"column":11},"end":{"line":127,"column":24}},"replacement":"true","id":"140","status":"Survived","testsCompleted":111},{"mutatorName":"ConditionalExpression","location":{"start":{"line":127,"column":11},"end":{"line":127,"column":24}},"replacement":"false","id":"141","status":"Killed","testsCompleted":74},{"mutatorName":"BooleanLiteral","location":{"start":{"line":145,"column":44},"end":{"line":145,"column":48}},"replacement":"false","id":"142","status":"Survived","testsCompleted":40},{"mutatorName":"BooleanLiteral","location":{"start":{"line":145,"column":50},"end":{"line":145,"column":55}},"replacement":"true","id":"143","status":"Killed","testsCompleted":35},{"mutatorName":"EqualityOperator","location":{"start":{"line":172,"column":56},"end":{"line":172,"column":58}},"replacement":"!=","id":"144","status":"Killed","testsCompleted":74},{"mutatorName":"LogicalOperator","location":{"start":{"line":172,"column":65},"end":{"line":172,"column":67}},"replacement":"&&","id":"145","status":"Killed","testsCompleted":74},{"mutatorName":"EqualityOperator","location":{"start":{"line":172,"column":87},"end":{"line":172,"column":89}},"replacement":"!=","id":"146","status":"Killed","testsCompleted":74},{"mutatorName":"ConditionalExpression","location":{"start":{"line":181,"column":24},"end":{"line":181,"column":38}},"replacement":"true","id":"147","status":"Survived","testsCompleted":79},{"mutatorName":"ConditionalExpression","location":{"start":{"line":181,"column":24},"end":{"line":181,"column":38}},"replacement":"false","id":"148","status":"Killed","testsCompleted":74},{"mutatorName":"MethodExpression","location":{"start":{"line":181,"column":24},"end":{"line":181,"column":38}},"replacement":"result.nonEmpty","id":"149","status":"Killed","testsCompleted":74}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/run/threshold/ThresholdChecker.scala":{"source":"package stryker4jvm.run.threshold\n\nimport stryker4jvm.config.Config\n\nobject ThresholdChecker {\n  def determineScoreStatus(mutationScore: Double)(implicit config: Config): ScoreStatus =\n    mutationScore match {\n      case score if score < config.thresholds.break => ErrorStatus\n      case score if score < config.thresholds.low   => DangerStatus\n      case score if score < config.thresholds.high  => WarningStatus\n      case _                                        => SuccessStatus\n    }\n}\n","mutants":[{"mutatorName":"EqualityOperator","location":{"start":{"line":8,"column":27},"end":{"line":8,"column":28}},"replacement":"<=","id":"186","status":"Killed","testsCompleted":13},{"mutatorName":"EqualityOperator","location":{"start":{"line":8,"column":27},"end":{"line":8,"column":28}},"replacement":">","id":"187","status":"Killed","testsCompleted":13},{"mutatorName":"EqualityOperator","location":{"start":{"line":8,"column":27},"end":{"line":8,"column":28}},"replacement":"==","id":"188","status":"Killed","testsCompleted":13},{"mutatorName":"EqualityOperator","location":{"start":{"line":9,"column":27},"end":{"line":9,"column":28}},"replacement":"<=","id":"189","status":"Killed","testsCompleted":13},{"mutatorName":"EqualityOperator","location":{"start":{"line":9,"column":27},"end":{"line":9,"column":28}},"replacement":">","id":"190","status":"Killed","testsCompleted":13},{"mutatorName":"EqualityOperator","location":{"start":{"line":9,"column":27},"end":{"line":9,"column":28}},"replacement":"==","id":"191","status":"Killed","testsCompleted":13},{"mutatorName":"EqualityOperator","location":{"start":{"line":10,"column":27},"end":{"line":10,"column":28}},"replacement":"<=","id":"192","status":"Killed","testsCompleted":13},{"mutatorName":"EqualityOperator","location":{"start":{"line":10,"column":27},"end":{"line":10,"column":28}},"replacement":">","id":"193","status":"Killed","testsCompleted":13},{"mutatorName":"EqualityOperator","location":{"start":{"line":10,"column":27},"end":{"line":10,"column":28}},"replacement":"==","id":"194","status":"Killed","testsCompleted":13}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/reporting/reporters/JsonReporter.scala":{"source":"package stryker4jvm.reporting.reporters\n\nimport cats.effect.IO\nimport fs2.io.file.Path\nimport mutationtesting.MutationTestResult\nimport stryker4jvm.config.Config\nimport stryker4jvm.files.FileIO\nimport stryker4jvm.logging.FansiLogger\nimport stryker4jvm.reporting.{FinishedRunEvent, IOReporter}\n\nclass JsonReporter(fileIO: FileIO)(implicit log: FansiLogger) extends IOReporter {\n\n  def writeReportJsonTo(file: Path, report: MutationTestResult[Config]): IO[Unit] = {\n    import io.circe.syntax.*\n    import mutationtesting.circe.*\n    val json = report.asJson.noSpaces\n    fileIO.createAndWrite(file, json)\n  }\n\n  override def onRunFinished(runReport: FinishedRunEvent): IO[Unit] = {\n    val resultLocation = fs2.io.file.Path.fromNioPath(runReport.reportsLocation) / \"report.json\"\n\n    writeReportJsonTo(resultLocation, runReport.report) *>\n      IO(log.info(s\"Written JSON report to $resultLocation\"))\n  }\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":21,"column":84},"end":{"line":21,"column":97}},"replacement":"\"\"","id":"303","status":"Killed","testsCompleted":3},{"mutatorName":"StringLiteral","location":{"start":{"line":24,"column":19},"end":{"line":24,"column":60}},"replacement":"\"\"","id":"304","status":"Killed","testsCompleted":3}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/mutants/Mutator.scala":{"source":"package stryker4jvm.mutants\n\nimport cats.Functor\nimport cats.effect.IO\nimport cats.syntax.all.*\nimport fansi.Color\nimport fs2.io.file.Path\nimport fs2.{Chunk, Pipe, Stream}\nimport mutationtesting.{MutantResult, MutantStatus}\nimport stryker4jvm.extensions.Stryker4jvmCoreConversions.*\n\nimport scala.collection.JavaConverters.*\nimport stryker4jvm.config.Config\nimport stryker4jvm.core.exception.Stryker4jvmException\nimport stryker4jvm.core.model.CollectedMutants.IgnoredMutation\nimport stryker4jvm.core.model.{\n  AST,\n  CollectedMutants,\n  CollectedMutantsWithId,\n  LanguageMutator,\n  MutantWithId,\n  MutatedCode\n}\nimport stryker4jvm.exception.InvalidFileTypeException\nimport stryker4jvm.extensions.Stryker4jvmCoreConversions\nimport stryker4jvm.logging.FansiLogger\nimport stryker4jvm.model.{MutantResultsPerFile, MutatedFile, SourceContext}\n\nimport java.util.concurrent.atomic.AtomicInteger\nimport java.util\nimport java.io.IOException\n\nclass Mutator(\n    mutantRouter: Map[String, LanguageMutator[? <: AST]]\n)(implicit\n    config: Config,\n    log: FansiLogger\n) {\n  def go(files: Stream[IO, Path]): IO[(MutantResultsPerFile, Seq[MutatedFile])] = {\n    files\n      // Parse and mutate files\n      .parEvalMap(config.concurrency) { path =>\n        val mutatorOption = mutantRouter.get(path.extName)\n        mutatorOption match {\n          case Some(mutator) =>\n            val source =\n              try\n                IO(mutator.parse(path.toNioPath))\n              catch {\n                case e: Stryker4jvmException => IO.raiseError(e)\n              }\n            source.map(tree => {\n              val foundMutations = mutator.collect(tree).asInstanceOf[CollectedMutants[AST]]\n              (SourceContext(tree, path), foundMutations)\n            })\n          case None => IO.raiseError(InvalidFileTypeException(path))\n        }\n      }\n      // Give each mutation a unique id\n      .through(updateWithId())\n      // Split mutations into active and ignored mutations\n      .flatMap { case (ctx, collectedWithId) =>\n        splitIgnoredAndFound(ctx, collectedWithId.mutantResults, collectedWithId.mutations)\n      }\n      // Instrument files\n      .parEvalMapUnordered(config.concurrency)(_.traverse { case (context, mutations) =>\n        val mutator = mutantRouter(context.path.extName)\n        val instrumented = mutator.instrument(context.source, mutations)\n        val mutants = mutations.asScala.values.map(_.asScala.toVector).toVector.flatten\n        val mutatedFile = MutatedFile(context.path, instrumented, mutants)\n        IO(log.debug(s\"Instrumenting mutations in ${mutations.size} places in ${context.path}\")) *>\n          IO(mutatedFile)\n      })\n      // Fold into 2 separate lists of ignored and found mutants (in files)\n      .through(foldAndSplitEithers)\n      .evalTap { case (ignored, files) => logMutationResult(ignored, files) }\n      .compile\n      .lastOrError\n  }\n\n  private def updateWithId()\n      : Pipe[IO, (SourceContext, CollectedMutants[AST]), (SourceContext, CollectedMutantsWithId[AST])] = {\n\n    def mapLeft(lefts: util.List[IgnoredMutation[AST]], i: AtomicInteger) = {\n      lefts.asScala.map { ignored =>\n        val reason = ignored.reason\n        val mutation = ignored.mutatedCode\n        MutantResult(\n          i.getAndIncrement().toString,\n          mutation.metaData.mutatorName,\n          mutation.metaData.replacement,\n          mutation.metaData.location.asMutationElement,\n          MutantStatus.Ignored,\n          statusReason = Some(reason.explanation)\n        ).asCoreElement\n      }.asJava\n    }\n\n    def mapRight(rights: util.Map[AST, util.List[MutatedCode[AST]]], i: AtomicInteger) = {\n      //   // Functor to use a deep map instead of .map(_.map...)\n      rights.asScala\n        .mapValues(mutations => mutations.asScala.map(mut => new MutantWithId(i.getAndIncrement(), mut)).asJava)\n        .toMap\n        .asJava\n    }\n\n    _.scanChunks(new AtomicInteger()) { case (i, chunk) =>\n      val out = Functor[Chunk]\n        .compose[(SourceContext, *)]\n        .map(chunk) { collected =>\n          new CollectedMutantsWithId[AST](\n            mapLeft(collected.ignoredMutations, i),\n            mapRight(collected.mutations, i)\n          )\n        }\n\n      (i, out)\n    }\n  }\n\n  private def splitIgnoredAndFound(\n      ctx: SourceContext,\n      ignored: util.List[stryker4jvm.core.model.elements.MutantResult],\n      found: util.Map[AST, util.List[MutantWithId[AST]]]\n  ) = {\n    val leftStream = Stream.emit((ctx.path, ignored.asScala.toVector.map(_.asMutationElement)).asLeft)\n    val rightStream = if (found.size() != 0) Stream.emit((ctx, found).asRight) else Stream.empty\n    leftStream ++ rightStream\n  }\n\n  private def logMutationResult(ignored: MutantResultsPerFile, mutatedFiles: Seq[MutatedFile]): IO[Unit] = {\n    val totalFiles = (mutatedFiles.map(_.fileOrigin) ++ ignored.keys).distinct.size\n    val includedMutants = mutatedFiles.map(_.mutants.size).sum\n    val excludedMutants = ignored.map(_._2.size).sum\n    val totalMutants = includedMutants + excludedMutants\n\n    def dryRunText(configProperties: String*): String =\n      s\"\"\"Stryker4s will perform a dry-run without actually mutating anything.\n         |You can configure the `${configProperties.mkString(\"` or `\")}` property in your configuration\"\"\".stripMargin\n\n    IO(log.info(s\"Found ${Color.Cyan(totalFiles.toString())} file(s) to be mutated.\")) *>\n      IO(\n        log.info(\n          s\"${Color.Cyan(totalMutants.toString())} mutant(s) generated.${(excludedMutants > 0)\n              .guard[Option]\n              .as(s\" Of which ${Color.LightRed(excludedMutants.toString())} mutant(s) are excluded.\")\n              .orEmpty}\"\n        )\n      ) *> {\n        if (includedMutants == 0 && excludedMutants > 0)\n          IO(log.warn(s\"All found mutations are excluded. ${dryRunText(\"mutate\", \"excluded-mutations\")}\"))\n        else\n          IO.whenA(totalMutants == 0) {\n            IO(log.info(\"Files to be mutated are found, but no mutations were found in those files.\")) *>\n              IO(log.info(\"If this is not intended, please check your configuration and try again.\"))\n          }\n      }\n  }\n\n  def foldAndSplitEithers[A, B, C]: Pipe[IO, Either[\n    (A, B),\n    C\n  ], (Map[A, B], Vector[C])] =\n    _.fold((Map.newBuilder[A, B], Vector.newBuilder[C])) {\n      case ((l, r), Right(f)) =>\n        (l, r += f)\n      case ((l, r), Left(f)) =>\n        (l += f, r)\n    }.map { case (l, r) => (l.result(), r.result()) }\n\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":71,"column":22},"end":{"line":71,"column":95}},"replacement":"\"\"","id":"142","status":"Survived","testsCompleted":8},{"mutatorName":"ConditionalExpression","location":{"start":{"line":127,"column":27},"end":{"line":127,"column":44}},"replacement":"true","id":"143","status":"Survived","testsCompleted":8},{"mutatorName":"ConditionalExpression","location":{"start":{"line":127,"column":27},"end":{"line":127,"column":44}},"replacement":"false","id":"144","status":"Killed","testsCompleted":7},{"mutatorName":"EqualityOperator","location":{"start":{"line":127,"column":40},"end":{"line":127,"column":42}},"replacement":"==","id":"145","status":"Killed","testsCompleted":7},{"mutatorName":"StringLiteral","location":{"start":{"line":138,"column":7},"end":{"line":139,"column":107}},"replacement":"\"\"","id":"146","status":"Killed","testsCompleted":7},{"mutatorName":"StringLiteral","location":{"start":{"line":139,"column":62},"end":{"line":139,"column":70}},"replacement":"\"\"","id":"147","status":"Killed","testsCompleted":7},{"mutatorName":"StringLiteral","location":{"start":{"line":141,"column":17},"end":{"line":141,"column":85}},"replacement":"\"\"","id":"148","status":"Killed","testsCompleted":7},{"mutatorName":"StringLiteral","location":{"start":{"line":144,"column":11},"end":{"line":147,"column":25}},"replacement":"\"\"","id":"149","status":"Killed","testsCompleted":7},{"mutatorName":"EqualityOperator","location":{"start":{"line":144,"column":91},"end":{"line":144,"column":92}},"replacement":">=","id":"150","status":"Survived","testsCompleted":8},{"mutatorName":"EqualityOperator","location":{"start":{"line":144,"column":91},"end":{"line":144,"column":92}},"replacement":"<","id":"151","status":"Killed","testsCompleted":7},{"mutatorName":"EqualityOperator","location":{"start":{"line":144,"column":91},"end":{"line":144,"column":92}},"replacement":"==","id":"152","status":"Killed","testsCompleted":7},{"mutatorName":"StringLiteral","location":{"start":{"line":146,"column":19},"end":{"line":146,"column":101}},"replacement":"\"\"","id":"153","status":"Killed","testsCompleted":7},{"mutatorName":"ConditionalExpression","location":{"start":{"line":150,"column":13},"end":{"line":150,"column":56}},"replacement":"true","id":"154","status":"Killed","testsCompleted":7},{"mutatorName":"ConditionalExpression","location":{"start":{"line":150,"column":13},"end":{"line":150,"column":56}},"replacement":"false","id":"155","status":"Killed","testsCompleted":7},{"mutatorName":"EqualityOperator","location":{"start":{"line":150,"column":29},"end":{"line":150,"column":31}},"replacement":"!=","id":"156","status":"Killed","testsCompleted":7},{"mutatorName":"LogicalOperator","location":{"start":{"line":150,"column":34},"end":{"line":150,"column":36}},"replacement":"||","id":"157","status":"Killed","testsCompleted":7},{"mutatorName":"EqualityOperator","location":{"start":{"line":150,"column":53},"end":{"line":150,"column":54}},"replacement":">=","id":"158","status":"Killed","testsCompleted":7},{"mutatorName":"EqualityOperator","location":{"start":{"line":150,"column":53},"end":{"line":150,"column":54}},"replacement":"<","id":"159","status":"Killed","testsCompleted":7},{"mutatorName":"EqualityOperator","location":{"start":{"line":150,"column":53},"end":{"line":150,"column":54}},"replacement":"==","id":"160","status":"Killed","testsCompleted":7},{"mutatorName":"StringLiteral","location":{"start":{"line":151,"column":23},"end":{"line":151,"column":105}},"replacement":"\"\"","id":"161","status":"Killed","testsCompleted":7},{"mutatorName":"StringLiteral","location":{"start":{"line":151,"column":72},"end":{"line":151,"column":80}},"replacement":"\"\"","id":"162","status":"Killed","testsCompleted":7},{"mutatorName":"StringLiteral","location":{"start":{"line":151,"column":82},"end":{"line":151,"column":102}},"replacement":"\"\"","id":"163","status":"Killed","testsCompleted":7},{"mutatorName":"EqualityOperator","location":{"start":{"line":153,"column":33},"end":{"line":153,"column":35}},"replacement":"!=","id":"164","status":"Killed","testsCompleted":7},{"mutatorName":"StringLiteral","location":{"start":{"line":154,"column":25},"end":{"line":154,"column":101}},"replacement":"\"\"","id":"165","status":"Killed","testsCompleted":7},{"mutatorName":"StringLiteral","location":{"start":{"line":155,"column":27},"end":{"line":155,"column":100}},"replacement":"\"\"","id":"166","status":"Killed","testsCompleted":7}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/extensions/mutationtype/NoArgMethodExpression.scala":{"source":"package stryker4jvm.mutator.scala.extensions.mutationtype\n\nimport scala.meta.Term\nimport scala.meta.Term.{Name, Select}\n\n/** Base method for methods call without arguments\n  */\nsealed trait NoArgMethodExpression extends MethodExpression {\n  def unapply(term: Term): Option[(Term, String => Term)] =\n    term match {\n      // foo.filter or foo filter\n      case Select(q, Name(`methodName`)) => Option((term, name => Select(q, Name(name))))\n      case _                             => None\n    }\n}\n\ncase object IsEmpty extends NoArgMethodExpression {\n  protected val methodName = \"isEmpty\"\n}\n\ncase object NonEmpty extends NoArgMethodExpression {\n  protected val methodName = \"nonEmpty\"\n}\n\ncase object Max extends NoArgMethodExpression {\n  protected val methodName = \"max\"\n}\n\ncase object Min extends NoArgMethodExpression {\n  protected val methodName = \"min\"\n}\n","mutants":[{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":18,"column":30},"end":{"line":18,"column":39}},"replacement":"\"\"","id":"107","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":22,"column":30},"end":{"line":22,"column":40}},"replacement":"\"\"","id":"108","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":26,"column":30},"end":{"line":26,"column":35}},"replacement":"\"\"","id":"109","status":"Ignored"},{"mutatorName":"StringLiteral","statusReason":"This is a 'static' mutant and can not be tested. If you still want to have this mutant tested, change your code to make this value initialize each time it is called.","location":{"start":{"line":30,"column":30},"end":{"line":30,"column":35}},"replacement":"\"\"","id":"110","status":"Ignored"}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/files/Glob.scala":{"source":"package stryker4jvm.files\n\nimport cats.effect.IO\nimport fs2.io.file.{Files, Path}\nimport stryker4jvm.extensions.StreamExtensions.FilterNotExtension\n\nimport java.nio.file\n\nobject Glob {\n\n  /** Create a PathMatcher for a given path that matches on the given glob patterns.\n    *\n    * @param path\n    *   the path to match\n    * @param patterns\n    *   the glob patterns to match on, any pattern starting with `!` will be a negative match\n    */\n  def matcher(path: Path, patterns: Seq[String]): PathMatcher = {\n    val (ignorePatterns, validPatterns) = patterns.partition(_.startsWith(\"!\"))\n    val ignorePatternsStripped = ignorePatterns.map(_.stripPrefix(\"!\"))\n\n    val separator = path.toNioPath.getFileSystem().getSeparator()\n\n    // Escape start of the path so it is not parsed as part of the glob expression, but as a literal\n    val escapedPath = (path.toString + separator)\n      .replace(\"\\\\\", \"\\\\\\\\\")\n      .replace(\"*\", \"\\\\*\")\n      .replace(\"?\", \"\\\\?\")\n      .replace(\"{\", \"\\\\{\")\n      .replace(\"}\", \"\\\\}\")\n      .replace(\"[\", \"\\\\[\")\n      .replace(\"]\", \"\\\\]\")\n\n    def toPathMatcher(glob: String): file.PathMatcher =\n      path.toNioPath.getFileSystem().getPathMatcher(s\"glob:$escapedPath$glob\")\n\n    val matchers = validPatterns.map(toPathMatcher)\n    val ignoreMatchers = ignorePatternsStripped.map(toPathMatcher)\n\n    new PathMatcher {\n      def matches(path: Path): Boolean =\n        matchers.exists(_.matches(path.toNioPath)) && !ignoreMatchers.exists(_.matches(path.toNioPath))\n    }\n  }\n\n  def glob(path: Path, list: Seq[String]): fs2.Stream[IO, Path] = {\n    val matcher = Glob.matcher(path, list)\n    Files[IO]\n      .walk(path)\n      .filterNot(!matcher.matches(_))\n      .evalFilterNot(Files[IO].isDirectory)\n  }\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":19,"column":75},"end":{"line":19,"column":78}},"replacement":"\"\"","id":"114","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":20,"column":67},"end":{"line":20,"column":70}},"replacement":"\"\"","id":"115","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":26,"column":16},"end":{"line":26,"column":20}},"replacement":"\"\"","id":"117","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":26,"column":22},"end":{"line":26,"column":28}},"replacement":"\"\"","id":"118","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":27,"column":16},"end":{"line":27,"column":19}},"replacement":"\"\"","id":"119","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":27,"column":21},"end":{"line":27,"column":26}},"replacement":"\"\"","id":"120","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":28,"column":16},"end":{"line":28,"column":19}},"replacement":"\"\"","id":"121","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":28,"column":21},"end":{"line":28,"column":26}},"replacement":"\"\"","id":"122","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":29,"column":16},"end":{"line":29,"column":19}},"replacement":"\"\"","id":"123","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":29,"column":21},"end":{"line":29,"column":26}},"replacement":"\"\"","id":"124","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":30,"column":16},"end":{"line":30,"column":19}},"replacement":"\"\"","id":"125","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":30,"column":21},"end":{"line":30,"column":26}},"replacement":"\"\"","id":"126","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":31,"column":16},"end":{"line":31,"column":19}},"replacement":"\"\"","id":"127","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":31,"column":21},"end":{"line":31,"column":26}},"replacement":"\"\"","id":"128","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":32,"column":16},"end":{"line":32,"column":19}},"replacement":"\"\"","id":"129","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":32,"column":21},"end":{"line":32,"column":26}},"replacement":"\"\"","id":"130","status":"Killed","testsCompleted":17},{"mutatorName":"StringLiteral","location":{"start":{"line":35,"column":53},"end":{"line":35,"column":78}},"replacement":"\"\"","id":"132","status":"Killed","testsCompleted":17},{"mutatorName":"MethodExpression","location":{"start":{"line":42,"column":9},"end":{"line":42,"column":51}},"replacement":"matchers.forall(_.matches(path.toNioPath))","id":"135","status":"Killed","testsCompleted":17},{"mutatorName":"LogicalOperator","location":{"start":{"line":42,"column":52},"end":{"line":42,"column":54}},"replacement":"||","id":"137","status":"Killed","testsCompleted":17},{"mutatorName":"MethodExpression","location":{"start":{"line":42,"column":56},"end":{"line":42,"column":104}},"replacement":"ignoreMatchers.forall(_.matches(path.toNioPath))","id":"139","status":"Killed","testsCompleted":17},{"mutatorName":"MethodExpression","location":{"start":{"line":48,"column":5},"end":{"line":50,"column":38}},"replacement":"Files[IO].walk(path).filter(!matcher.matches(_))","id":"141","status":"Killed","testsCompleted":5}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/config/DebugOptions.scala":{"source":"package stryker4jvm.config\n\nfinal case class DebugOptions(\n    logTestRunnerStdout: Boolean = false,\n    debugTestRunner: Boolean = false\n)\n","mutants":[{"mutatorName":"BooleanLiteral","location":{"start":{"line":4,"column":36},"end":{"line":4,"column":41}},"replacement":"true","id":"26","status":"Survived","testsCompleted":57},{"mutatorName":"BooleanLiteral","location":{"start":{"line":5,"column":32},"end":{"line":5,"column":37}},"replacement":"true","id":"27","status":"Survived","testsCompleted":57}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/config/TestFilter.scala":{"source":"package stryker4jvm.config\n\nimport java.util.regex.Pattern\nimport scala.util.Try\nimport stryker4jvm.config.TestFilter.wildcardToRegex\n\nclass TestFilter()(implicit config: Config) {\n\n  val exclamationMark = \"!\"\n\n  lazy val partition: Partition = config.testFilter.partition(_.startsWith(exclamationMark)) match {\n    case (negative, positive) =>\n      Partition(\n        negative.map(p => Regex(wildcardToRegex(p.substring(1)))),\n        positive.map(p => Regex(wildcardToRegex(p)))\n      )\n  }\n\n  def filter(testName: String): Boolean = {\n    def matches(regexSeq: Seq[Regex]): Boolean =\n      regexSeq.foldLeft(false)((acc, regex) => acc || regex.matches(testName))\n\n    if (matches(partition.negative))\n      false\n    else\n      partition.positive.isEmpty || matches(partition.positive)\n  }\n}\n\nfinal case class Partition(negative: Seq[Regex], positive: Seq[Regex])\n\nfinal case class Regex(regex: String) extends AnyVal {\n  def matches(testName: String): Boolean = Try(Pattern.matches(regex, testName)).getOrElse(false)\n}\n\nobject TestFilter {\n\n  def wildcardToRegex(wildcard: String): String = s\"^${wildcard.toList.map(convertChar).mkString}$$\"\n\n  def convertChar(c: Char): String =\n    c match {\n      case '*'                 => \".*\"\n      case '?'                 => \".\"\n      case _ if isRegexChar(c) => \"\\\\\" + c.toString\n      case c                   => c.toString\n    }\n\n  def isRegexChar(c: Char): Boolean =\n    Seq('(', ')', '[', ']', '$', '^', '.', '{', '}', '|', '\\\\').foldLeft(false)((acc, elt) => acc || c == elt)\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":9,"column":25},"end":{"line":9,"column":28}},"replacement":"\"\"","id":"80","status":"Killed","testsCompleted":3},{"mutatorName":"BooleanLiteral","location":{"start":{"line":21,"column":25},"end":{"line":21,"column":30}},"replacement":"true","id":"81","status":"Killed","testsCompleted":3},{"mutatorName":"LogicalOperator","location":{"start":{"line":21,"column":52},"end":{"line":21,"column":54}},"replacement":"&&","id":"82","status":"Killed","testsCompleted":3},{"mutatorName":"ConditionalExpression","location":{"start":{"line":23,"column":9},"end":{"line":23,"column":36}},"replacement":"true","id":"83","status":"Killed","testsCompleted":3},{"mutatorName":"ConditionalExpression","location":{"start":{"line":23,"column":9},"end":{"line":23,"column":36}},"replacement":"false","id":"84","status":"Killed","testsCompleted":3},{"mutatorName":"BooleanLiteral","location":{"start":{"line":24,"column":7},"end":{"line":24,"column":12}},"replacement":"true","id":"85","status":"Killed","testsCompleted":3},{"mutatorName":"MethodExpression","location":{"start":{"line":26,"column":7},"end":{"line":26,"column":33}},"replacement":"partition.positive.nonEmpty","id":"86","status":"Killed","testsCompleted":3},{"mutatorName":"LogicalOperator","location":{"start":{"line":26,"column":34},"end":{"line":26,"column":36}},"replacement":"&&","id":"87","status":"Killed","testsCompleted":3},{"mutatorName":"BooleanLiteral","location":{"start":{"line":33,"column":92},"end":{"line":33,"column":97}},"replacement":"true","id":"88","status":"Survived","testsCompleted":3},{"mutatorName":"StringLiteral","location":{"start":{"line":38,"column":51},"end":{"line":38,"column":101}},"replacement":"\"\"","id":"89","status":"Killed","testsCompleted":3},{"mutatorName":"StringLiteral","location":{"start":{"line":42,"column":35},"end":{"line":42,"column":39}},"replacement":"\"\"","id":"90","status":"Killed","testsCompleted":3},{"mutatorName":"StringLiteral","location":{"start":{"line":43,"column":35},"end":{"line":43,"column":38}},"replacement":"\"\"","id":"91","status":"Survived","testsCompleted":3},{"mutatorName":"StringLiteral","location":{"start":{"line":44,"column":35},"end":{"line":44,"column":39}},"replacement":"\"\"","id":"92","status":"Survived","testsCompleted":3},{"mutatorName":"BooleanLiteral","location":{"start":{"line":49,"column":74},"end":{"line":49,"column":79}},"replacement":"true","id":"93","status":"Killed","testsCompleted":3},{"mutatorName":"LogicalOperator","location":{"start":{"line":49,"column":99},"end":{"line":49,"column":101}},"replacement":"&&","id":"94","status":"Survived","testsCompleted":3},{"mutatorName":"EqualityOperator","location":{"start":{"line":49,"column":104},"end":{"line":49,"column":106}},"replacement":"!=","id":"95","status":"Killed","testsCompleted":3}],"language":"scala"},"stryker4jvm/src/main/scala/stryker4jvm/config/pure/ConfigConfigReader.scala":{"source":"package stryker4jvm.config.pure\n\nimport cats.syntax.either.*\nimport fs2.io.file.Path\nimport pureconfig.ConfigReader\nimport pureconfig.error.CannotConvert\nimport pureconfig.generic.semiauto.*\nimport stryker4jvm.config.*\nimport stryker4jvm.core.config.LanguageMutatorConfig\nimport sttp.model.Uri\n\nimport java.nio.file.Path as JPath\nimport scala.collection.JavaConverters.{asScalaSet, setAsJavaSet}\nimport scala.meta.{dialects, Dialect}\n\n/** Conversions of custom case classes or enums so PureConfig can read it.\n  *\n  * @example\n  *   `pathReader` makes PureConfig able to read `fs2.io.file.Path` from a `java.nio.file.Path`\n  */\ntrait ConfigConfigReader {\n\n  implicit def pathReader: ConfigReader[Path] =\n    ConfigReader[JPath].map(Path.fromNioPath).map(_.absolute)\n\n  implicit def reporterReader: ConfigReader[ReporterType] =\n    deriveEnumerationReader[ReporterType]\n\n  implicit def dashboardReportTypeReader: ConfigReader[DashboardReportType] =\n    deriveEnumerationReader[DashboardReportType]\n\n  implicit def exclusionsReader: ConfigReader[Config.ExcludedMutations] =\n    ConfigReader[List[String]] emap { exclusions =>\n      exclusions.toSet.asRight\n    // todo: This validation should be done by the language specific implementations!\n    //      val (valid, invalid) = exclusions.partition(Mutation.mutations.contains)\n    //      if (invalid.nonEmpty)\n    //        CannotConvert(\n    //          exclusions.mkString(\", \"),\n    //          s\"excluded-mutations\",\n    //          s\"invalid option(s) '${invalid.mkString(\", \")}'. Valid exclusions are '${Mutation.mutations.mkString(\", \")}'\"\n    //        ).asLeft\n    //      else\n    //        valid.toSet.asRight\n    }\n\n  implicit def languageMutatorConfigReader: ConfigReader[LanguageMutatorConfig] = {\n    ConfigReader[ConfigLanguageMutatorConfig].map { config =>\n      new LanguageMutatorConfig(config.dialect.orNull, setAsJavaSet(config.excludedMutations.getOrElse(Set.empty)))\n    }\n  }\n\n  implicit def configLanguageMutatorConfigReader: ConfigReader[ConfigLanguageMutatorConfig] = {\n    deriveReader[ConfigLanguageMutatorConfig]\n  }\n\n  implicit def uriReader: ConfigReader[Uri] = _root_.pureconfig.module.sttp.reader\n\n  implicit def thresholdsReader: ConfigReader[Thresholds] = {\n    def isNotPercentage(n: Int) = n < 0 || n > 100\n\n    def notPercentageError(value: Int, name: String): Either[CannotConvert, Thresholds] =\n      CannotConvert(value.toString(), s\"thresholds.$name\", \"must be a percentage 0-100\").asLeft\n\n    deriveReader[Thresholds] emap {\n      case Thresholds(high, _, _) if isNotPercentage(high)   => notPercentageError(high, \"high\")\n      case Thresholds(_, low, _) if isNotPercentage(low)     => notPercentageError(low, \"low\")\n      case Thresholds(_, _, break) if isNotPercentage(break) => notPercentageError(break, \"break\")\n      case Thresholds(high, low, _) if high < low =>\n        CannotConvert(\n          high.toString(),\n          \"thresholds.high\",\n          s\"'high' ($high) must be greater than or equal to 'low' ($low)\"\n        ).asLeft\n      case Thresholds(_, low, break) if low <= break =>\n        CannotConvert(\n          low.toString(),\n          \"thresholds.low\",\n          s\"'low' ($low) must be greater than 'break' ($break)\"\n        ).asLeft\n      case valid => valid.asRight\n    }\n  }\n\n  implicit def dialectReader: ConfigReader[Dialect] = {\n    val deprecatedVersions = List(\"scala211\", \"scala2.11\", \"2.11\", \"211\")\n\n    val scalaVersions = Map(\n      List(\"scala212\", \"scala2.12\", \"2.12\", \"212\") -> dialects.Scala212,\n      List(\"scala212source3\") -> dialects.Scala212Source3,\n      List(\"scala213\", \"scala2.13\", \"2.13\", \"213\", \"2\") -> dialects.Scala213,\n      List(\"scala213source3\", \"source3\") -> dialects.Scala213Source3,\n      List(\"scala3future\", \"future\") -> dialects.Scala3Future,\n      List(\"scala30\", \"scala3.0\", \"3.0\", \"30\", \"dotty\") -> dialects.Scala30,\n      List(\"scala31\", \"scala3.1\", \"3.1\", \"31\") -> dialects.Scala31,\n      List(\"scala32\", \"scala3.2\", \"3.2\", \"32\") -> dialects.Scala32,\n      List(\"scala3\", \"scala3.0\", \"3.0\", \"3\") -> dialects.Scala3\n    )\n\n    ConfigReader[String].emap { input =>\n      def toCannotConvert(msg: String) = {\n        val invalidDialectString =\n          s\"Leaving this configuration empty defaults to scala213source3 which might also work for you. Valid scalaDialects are: \" +\n            s\"${scalaVersions.keys.flatten\n                .map(d => s\"'$d'\")\n                .mkString(\", \")}\"\n        CannotConvert(input, \"scala-dialect\", s\"$msg. $invalidDialectString\")\n      }\n\n      if (deprecatedVersions.contains(input))\n        toCannotConvert(\"Deprecated dialect\").asLeft\n      else\n        scalaVersions\n          .collectFirst { case (strings, dialect) if strings.contains(input.toLowerCase()) => dialect }\n          .toRight(toCannotConvert(\"Unsupported dialect\"))\n    }\n  }\n\n}\n","mutants":[{"mutatorName":"EqualityOperator","location":{"start":{"line":60,"column":37},"end":{"line":60,"column":38}},"replacement":"<=","id":"231","status":"Killed","testsCompleted":27},{"mutatorName":"EqualityOperator","location":{"start":{"line":60,"column":37},"end":{"line":60,"column":38}},"replacement":">","id":"232","status":"Killed","testsCompleted":27},{"mutatorName":"EqualityOperator","location":{"start":{"line":60,"column":37},"end":{"line":60,"column":38}},"replacement":"==","id":"233","status":"Killed","testsCompleted":27},{"mutatorName":"LogicalOperator","location":{"start":{"line":60,"column":41},"end":{"line":60,"column":43}},"replacement":"&&","id":"234","status":"Killed","testsCompleted":27},{"mutatorName":"EqualityOperator","location":{"start":{"line":60,"column":46},"end":{"line":60,"column":47}},"replacement":">=","id":"235","status":"Killed","testsCompleted":27},{"mutatorName":"EqualityOperator","location":{"start":{"line":60,"column":46},"end":{"line":60,"column":47}},"replacement":"<","id":"236","status":"Killed","testsCompleted":27},{"mutatorName":"EqualityOperator","location":{"start":{"line":60,"column":46},"end":{"line":60,"column":47}},"replacement":"==","id":"237","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":63,"column":39},"end":{"line":63,"column":58}},"replacement":"\"\"","id":"238","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":63,"column":60},"end":{"line":63,"column":88}},"replacement":"\"\"","id":"239","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":66,"column":90},"end":{"line":66,"column":96}},"replacement":"\"\"","id":"240","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":67,"column":89},"end":{"line":67,"column":94}},"replacement":"\"\"","id":"241","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":68,"column":91},"end":{"line":68,"column":98}},"replacement":"\"\"","id":"242","status":"Killed","testsCompleted":27},{"mutatorName":"EqualityOperator","location":{"start":{"line":69,"column":45},"end":{"line":69,"column":46}},"replacement":"<=","id":"243","status":"Killed","testsCompleted":27},{"mutatorName":"EqualityOperator","location":{"start":{"line":69,"column":45},"end":{"line":69,"column":46}},"replacement":">","id":"244","status":"Killed","testsCompleted":27},{"mutatorName":"EqualityOperator","location":{"start":{"line":69,"column":45},"end":{"line":69,"column":46}},"replacement":"==","id":"245","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":72,"column":11},"end":{"line":72,"column":28}},"replacement":"\"\"","id":"246","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":73,"column":11},"end":{"line":73,"column":74}},"replacement":"\"\"","id":"247","status":"Killed","testsCompleted":27},{"mutatorName":"EqualityOperator","location":{"start":{"line":75,"column":45},"end":{"line":75,"column":47}},"replacement":"<","id":"248","status":"Killed","testsCompleted":27},{"mutatorName":"EqualityOperator","location":{"start":{"line":75,"column":45},"end":{"line":75,"column":47}},"replacement":">=","id":"249","status":"Killed","testsCompleted":27},{"mutatorName":"EqualityOperator","location":{"start":{"line":75,"column":45},"end":{"line":75,"column":47}},"replacement":"==","id":"250","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":78,"column":11},"end":{"line":78,"column":27}},"replacement":"\"\"","id":"251","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":79,"column":11},"end":{"line":79,"column":64}},"replacement":"\"\"","id":"252","status":"Killed","testsCompleted":27},{"mutatorName":"StringLiteral","location":{"start":{"line":86,"column":35},"end":{"line":86,"column":45}},"replacement":"\"\"","id":"253","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":86,"column":47},"end":{"line":86,"column":58}},"replacement":"\"\"","id":"254","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":86,"column":60},"end":{"line":86,"column":66}},"replacement":"\"\"","id":"255","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":86,"column":68},"end":{"line":86,"column":73}},"replacement":"\"\"","id":"256","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":89,"column":12},"end":{"line":89,"column":22}},"replacement":"\"\"","id":"257","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":89,"column":24},"end":{"line":89,"column":35}},"replacement":"\"\"","id":"258","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":89,"column":37},"end":{"line":89,"column":43}},"replacement":"\"\"","id":"259","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":89,"column":45},"end":{"line":89,"column":50}},"replacement":"\"\"","id":"260","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":90,"column":12},"end":{"line":90,"column":29}},"replacement":"\"\"","id":"261","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":91,"column":12},"end":{"line":91,"column":22}},"replacement":"\"\"","id":"262","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":91,"column":24},"end":{"line":91,"column":35}},"replacement":"\"\"","id":"263","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":91,"column":37},"end":{"line":91,"column":43}},"replacement":"\"\"","id":"264","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":91,"column":45},"end":{"line":91,"column":50}},"replacement":"\"\"","id":"265","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":91,"column":52},"end":{"line":91,"column":55}},"replacement":"\"\"","id":"266","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":92,"column":12},"end":{"line":92,"column":29}},"replacement":"\"\"","id":"267","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":92,"column":31},"end":{"line":92,"column":40}},"replacement":"\"\"","id":"268","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":93,"column":12},"end":{"line":93,"column":26}},"replacement":"\"\"","id":"269","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":93,"column":28},"end":{"line":93,"column":36}},"replacement":"\"\"","id":"270","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":94,"column":12},"end":{"line":94,"column":21}},"replacement":"\"\"","id":"271","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":94,"column":23},"end":{"line":94,"column":33}},"replacement":"\"\"","id":"272","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":94,"column":35},"end":{"line":94,"column":40}},"replacement":"\"\"","id":"273","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":94,"column":42},"end":{"line":94,"column":46}},"replacement":"\"\"","id":"274","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":94,"column":48},"end":{"line":94,"column":55}},"replacement":"\"\"","id":"275","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":95,"column":12},"end":{"line":95,"column":21}},"replacement":"\"\"","id":"276","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":95,"column":23},"end":{"line":95,"column":33}},"replacement":"\"\"","id":"277","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":95,"column":35},"end":{"line":95,"column":40}},"replacement":"\"\"","id":"278","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":95,"column":42},"end":{"line":95,"column":46}},"replacement":"\"\"","id":"279","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":96,"column":12},"end":{"line":96,"column":21}},"replacement":"\"\"","id":"280","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":96,"column":23},"end":{"line":96,"column":33}},"replacement":"\"\"","id":"281","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":96,"column":35},"end":{"line":96,"column":40}},"replacement":"\"\"","id":"282","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":96,"column":42},"end":{"line":96,"column":46}},"replacement":"\"\"","id":"283","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":97,"column":12},"end":{"line":97,"column":20}},"replacement":"\"\"","id":"284","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":97,"column":22},"end":{"line":97,"column":32}},"replacement":"\"\"","id":"285","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":97,"column":34},"end":{"line":97,"column":39}},"replacement":"\"\"","id":"286","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":97,"column":41},"end":{"line":97,"column":44}},"replacement":"\"\"","id":"287","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":103,"column":11},"end":{"line":103,"column":131}},"replacement":"\"\"","id":"288","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":104,"column":13},"end":{"line":106,"column":34}},"replacement":"\"\"","id":"289","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":105,"column":27},"end":{"line":105,"column":34}},"replacement":"\"\"","id":"290","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":106,"column":27},"end":{"line":106,"column":31}},"replacement":"\"\"","id":"291","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":107,"column":30},"end":{"line":107,"column":45}},"replacement":"\"\"","id":"292","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":107,"column":47},"end":{"line":107,"column":77}},"replacement":"\"\"","id":"293","status":"NoCoverage"},{"mutatorName":"ConditionalExpression","location":{"start":{"line":110,"column":11},"end":{"line":110,"column":45}},"replacement":"true","id":"294","status":"NoCoverage"},{"mutatorName":"ConditionalExpression","location":{"start":{"line":110,"column":11},"end":{"line":110,"column":45}},"replacement":"false","id":"295","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":111,"column":25},"end":{"line":111,"column":45}},"replacement":"\"\"","id":"296","status":"NoCoverage"},{"mutatorName":"StringLiteral","location":{"start":{"line":115,"column":36},"end":{"line":115,"column":57}},"replacement":"\"\"","id":"297","status":"NoCoverage"}],"language":"scala"},"stryker4jvm-mutator-scala/src/main/scala/stryker4jvm/mutator/scala/extensions/RegexParseError.scala":{"source":"package stryker4jvm.mutator.scala.extensions\nimport stryker4jvm.core.model.IgnoredMutationReason\n\nfinal case class RegexParseError(pattern: String, message: String) extends IgnoredMutationReason {\n\n  override def explanation(): String =\n    s\"The Regex parser of weapon-regex couldn't parse this regex pattern: '$pattern'. Please report this issue at https://github.com/stryker-mutator/weapon-regex/issues. Inner error: $message\"\n\n}\n","mutants":[{"mutatorName":"StringLiteral","location":{"start":{"line":7,"column":5},"end":{"line":7,"column":193}},"replacement":"\"\"","id":"102","status":"NoCoverage"}],"language":"scala"}},"config":{"reporters":["html","json"],"excluded-mutations":[],"scala-dialect":"scala3","dashboard":{"base-url":"https://dashboard.stryker-mutator.io","report-type":"full"},"legacy-test-runner":false,"base-dir":"/home/michael/Documents/Study/ISEP/stryker4jvm","files":[],"debug":{"log-test-runner-stdout":false,"debug-test-runner":false},"timeout-factor":1.5,"mutate":[],"thresholds":{"high":80,"low":60,"break":0},"test-filter":[],"timeout":5000}}