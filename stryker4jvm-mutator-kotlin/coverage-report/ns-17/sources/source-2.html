


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > MutantMatcher</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/highlight-idea.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">stryker4jvm.mutator.scala</a>
</div>

<h1>Coverage Summary for Class: MutantMatcher (stryker4jvm.mutator.scala)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">MutantMatcher$</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<div class="sourceCode" id="sourceCode"><i class="no-highlight">1</i>&nbsp;package stryker4jvm.mutator.scala
<i class="no-highlight">2</i>&nbsp;
<i class="no-highlight">3</i>&nbsp;import scala.meta.*
<i class="no-highlight">4</i>&nbsp;
<i class="no-highlight">5</i>&nbsp;import MutantMatcher.MutationMatcher
<i class="no-highlight">6</i>&nbsp;import stryker4jvm.core.model.CollectedMutants.IgnoredMutation
<i class="no-highlight">7</i>&nbsp;import stryker4jvm.core.model.MutatedCode
<i class="no-highlight">8</i>&nbsp;import stryker4jvm.mutator.scala.PlaceableTree
<i class="no-highlight">9</i>&nbsp;import stryker4jvm.core.model.MutantMetaData
<i class="no-highlight">10</i>&nbsp;
<i class="no-highlight">11</i>&nbsp;import cats.syntax.semigroup.*
<i class="no-highlight">12</i>&nbsp;
<i class="no-highlight">13</i>&nbsp;import stryker4jvm.mutator.scala.extensions.PartialFunctionOps.*
<i class="no-highlight">14</i>&nbsp;import stryker4jvm.mutator.scala.extensions.TreeExtensions.{IsEqualExtension, PositionExtension, TransformOnceExtension}
<i class="no-highlight">15</i>&nbsp;
<i class="no-highlight">16</i>&nbsp;import stryker4jvm.mutator.scala.extensions.mutationtype.*
<i class="no-highlight">17</i>&nbsp;import stryker4jvm.core.model
<i class="no-highlight">18</i>&nbsp;import stryker4jvm.core.config.LanguageMutatorConfig
<i class="no-highlight">19</i>&nbsp;
<i class="no-highlight">20</i>&nbsp;import scala.annotation.tailrec
<i class="no-highlight">21</i>&nbsp;
<i class="no-highlight">22</i>&nbsp;trait MutantMatcher {
<i class="no-highlight">23</i>&nbsp;
<i class="no-highlight">24</i>&nbsp;  /** Matches on all types of mutations and returns a list of all the mutations that were found.
<i class="no-highlight">25</i>&nbsp;    */
<i class="no-highlight">26</i>&nbsp;  def allMatchers: MutationMatcher
<i class="no-highlight">27</i>&nbsp;}
<i class="no-highlight">28</i>&nbsp;
<b class="nc"><i class="no-highlight">29</i>&nbsp;object MutantMatcher {</b>
<i class="no-highlight">30</i>&nbsp;
<i class="no-highlight">31</i>&nbsp;  /** A PartialFunction that can match on a ScalaMeta tree and return a `Either[IgnoredMutations, Mutations]`.
<i class="no-highlight">32</i>&nbsp;    *
<i class="no-highlight">33</i>&nbsp;    * If the result is a `Left`, it means a mutant was found, but ignored. The ADT
<i class="no-highlight">34</i>&nbsp;    * [[stryker4jvm.core.model.IgnoredMutationReason]] shows the possible reasons.
<i class="no-highlight">35</i>&nbsp;    */
<i class="no-highlight">36</i>&nbsp;  type MutationMatcher =
<i class="no-highlight">37</i>&nbsp;    PartialFunction[Tree, PlaceableTree =&gt; Either[Vector[IgnoredMutation[ScalaAST]], Vector[MutatedCode[ScalaAST]]]]
<i class="no-highlight">38</i>&nbsp;
<i class="no-highlight">39</i>&nbsp;}
<i class="no-highlight">40</i>&nbsp;
<i class="no-highlight">41</i>&nbsp;class MutantMatcherImpl(var config: LanguageMutatorConfig) extends MutantMatcher {
<i class="no-highlight">42</i>&nbsp;
<i class="no-highlight">43</i>&nbsp;  override def allMatchers: MutationMatcher = {
<i class="no-highlight">44</i>&nbsp;    matchBooleanLiteral orElse
<i class="no-highlight">45</i>&nbsp;      matchEqualityOperator orElse
<i class="no-highlight">46</i>&nbsp;      matchLogicalOperator orElse
<i class="no-highlight">47</i>&nbsp;      matchConditionalExpression orElse
<i class="no-highlight">48</i>&nbsp;      matchMethodExpression orElse
<i class="no-highlight">49</i>&nbsp;      matchStringsAndRegex
<i class="no-highlight">50</i>&nbsp;  }
<i class="no-highlight">51</i>&nbsp;
<i class="no-highlight">52</i>&nbsp;  def matchBooleanLiteral: MutationMatcher = {
<i class="no-highlight">53</i>&nbsp;    case True(orig)  =&gt; createMutations(orig)(False)
<i class="no-highlight">54</i>&nbsp;    case False(orig) =&gt; createMutations(orig)(True)
<i class="no-highlight">55</i>&nbsp;  }
<i class="no-highlight">56</i>&nbsp;
<i class="no-highlight">57</i>&nbsp;  def matchEqualityOperator: MutationMatcher = {
<i class="no-highlight">58</i>&nbsp;    case GreaterThanEqualTo(orig) =&gt; createMutations(orig)(GreaterThan, LesserThan, EqualTo)
<i class="no-highlight">59</i>&nbsp;    case GreaterThan(orig)        =&gt; createMutations(orig)(GreaterThanEqualTo, LesserThan, EqualTo)
<i class="no-highlight">60</i>&nbsp;    case LesserThanEqualTo(orig)  =&gt; createMutations(orig)(LesserThan, GreaterThanEqualTo, EqualTo)
<i class="no-highlight">61</i>&nbsp;    case LesserThan(orig)         =&gt; createMutations(orig)(LesserThanEqualTo, GreaterThan, EqualTo)
<i class="no-highlight">62</i>&nbsp;    case EqualTo(orig)            =&gt; createMutations(orig)(NotEqualTo)
<i class="no-highlight">63</i>&nbsp;    case NotEqualTo(orig)         =&gt; createMutations(orig)(EqualTo)
<i class="no-highlight">64</i>&nbsp;    case TypedEqualTo(orig)       =&gt; createMutations(orig)(TypedNotEqualTo)
<i class="no-highlight">65</i>&nbsp;    case TypedNotEqualTo(orig)    =&gt; createMutations(orig)(TypedEqualTo)
<i class="no-highlight">66</i>&nbsp;  }
<i class="no-highlight">67</i>&nbsp;
<i class="no-highlight">68</i>&nbsp;  def matchLogicalOperator: MutationMatcher = {
<i class="no-highlight">69</i>&nbsp;    case And(orig) =&gt; createMutations(orig)(Or)
<i class="no-highlight">70</i>&nbsp;    case Or(orig)  =&gt; createMutations(orig)(And)
<i class="no-highlight">71</i>&nbsp;  }
<i class="no-highlight">72</i>&nbsp;
<i class="no-highlight">73</i>&nbsp;  def matchConditionalExpression: MutationMatcher = {
<i class="no-highlight">74</i>&nbsp;    case If(orig)      =&gt; createMutations(orig)(ConditionalTrue, ConditionalFalse)
<i class="no-highlight">75</i>&nbsp;    case While(orig)   =&gt; createMutations(orig)(ConditionalFalse)
<i class="no-highlight">76</i>&nbsp;    case DoWhile(orig) =&gt; createMutations(orig)(ConditionalFalse)
<i class="no-highlight">77</i>&nbsp;  }
<i class="no-highlight">78</i>&nbsp;
<i class="no-highlight">79</i>&nbsp;  def matchMethodExpression: MutationMatcher = {
<i class="no-highlight">80</i>&nbsp;    case Filter(orig, f)      =&gt; createMutations(orig, f, FilterNot)
<i class="no-highlight">81</i>&nbsp;    case FilterNot(orig, f)   =&gt; createMutations(orig, f, Filter)
<i class="no-highlight">82</i>&nbsp;    case Exists(orig, f)      =&gt; createMutations(orig, f, Forall)
<i class="no-highlight">83</i>&nbsp;    case Forall(orig, f)      =&gt; createMutations(orig, f, Exists)
<i class="no-highlight">84</i>&nbsp;    case Take(orig, f)        =&gt; createMutations(orig, f, Drop)
<i class="no-highlight">85</i>&nbsp;    case Drop(orig, f)        =&gt; createMutations(orig, f, Take)
<i class="no-highlight">86</i>&nbsp;    case TakeRight(orig, f)   =&gt; createMutations(orig, f, DropRight)
<i class="no-highlight">87</i>&nbsp;    case DropRight(orig, f)   =&gt; createMutations(orig, f, TakeRight)
<i class="no-highlight">88</i>&nbsp;    case TakeWhile(orig, f)   =&gt; createMutations(orig, f, DropWhile)
<i class="no-highlight">89</i>&nbsp;    case DropWhile(orig, f)   =&gt; createMutations(orig, f, TakeWhile)
<i class="no-highlight">90</i>&nbsp;    case IsEmpty(orig, f)     =&gt; createMutations(orig, f, NonEmpty)
<i class="no-highlight">91</i>&nbsp;    case NonEmpty(orig, f)    =&gt; createMutations(orig, f, IsEmpty)
<i class="no-highlight">92</i>&nbsp;    case IndexOf(orig, f)     =&gt; createMutations(orig, f, LastIndexOf)
<i class="no-highlight">93</i>&nbsp;    case LastIndexOf(orig, f) =&gt; createMutations(orig, f, IndexOf)
<i class="no-highlight">94</i>&nbsp;    case Max(orig, f)         =&gt; createMutations(orig, f, Min)
<i class="no-highlight">95</i>&nbsp;    case Min(orig, f)         =&gt; createMutations(orig, f, Max)
<i class="no-highlight">96</i>&nbsp;    case MaxBy(orig, f)       =&gt; createMutations(orig, f, MinBy)
<i class="no-highlight">97</i>&nbsp;    case MinBy(orig, f)       =&gt; createMutations(orig, f, MaxBy)
<i class="no-highlight">98</i>&nbsp;  }
<i class="no-highlight">99</i>&nbsp;
<i class="no-highlight">100</i>&nbsp;  def matchStringLiteral: MutationMatcher = {
<i class="no-highlight">101</i>&nbsp;    case EmptyString(orig)         =&gt; createMutations(orig)(StrykerWasHereString)
<i class="no-highlight">102</i>&nbsp;    case NonEmptyString(orig)      =&gt; createMutations(orig)(EmptyString)
<i class="no-highlight">103</i>&nbsp;    case StringInterpolation(orig) =&gt; createMutations(orig)(EmptyString)
<i class="no-highlight">104</i>&nbsp;  }
<i class="no-highlight">105</i>&nbsp;
<i class="no-highlight">106</i>&nbsp;  def matchRegex: MutationMatcher = {
<i class="no-highlight">107</i>&nbsp;    case RegexConstructor(orig)   =&gt; createMutations(orig, RegexMutations(orig))
<i class="no-highlight">108</i>&nbsp;    case RegexStringOps(orig)     =&gt; createMutations(orig, RegexMutations(orig))
<i class="no-highlight">109</i>&nbsp;    case PatternConstructor(orig) =&gt; createMutations(orig, RegexMutations(orig))
<i class="no-highlight">110</i>&nbsp;  }
<i class="no-highlight">111</i>&nbsp;
<i class="no-highlight">112</i>&nbsp;  /** Match both strings and regexes instead of stopping when one of them gives a match
<i class="no-highlight">113</i>&nbsp;    */
<i class="no-highlight">114</i>&nbsp;  def matchStringsAndRegex: MutationMatcher = matchStringLiteral combine matchRegex
<i class="no-highlight">115</i>&nbsp;
<i class="no-highlight">116</i>&nbsp;  private def createMutations[T &lt;: Term](
<i class="no-highlight">117</i>&nbsp;      original: Term
<i class="no-highlight">118</i>&nbsp;  )(
<i class="no-highlight">119</i>&nbsp;      firstReplacement: SubstitutionMutation[T],
<i class="no-highlight">120</i>&nbsp;      restReplacements: SubstitutionMutation[T]*
<i class="no-highlight">121</i>&nbsp;  ): PlaceableTree =&gt; Either[Vector[IgnoredMutation[ScalaAST]], Vector[MutatedCode[ScalaAST]]] = {
<i class="no-highlight">122</i>&nbsp;    val replacements: Vector[SubstitutionMutation[T]] =
<i class="no-highlight">123</i>&nbsp;      Vector(firstReplacement) ++ restReplacements.toVector
<i class="no-highlight">124</i>&nbsp;    buildMutations[SubstitutionMutation[T]](original, replacements, _.tree)
<i class="no-highlight">125</i>&nbsp;  }
<i class="no-highlight">126</i>&nbsp;
<i class="no-highlight">127</i>&nbsp;  private def createMutations[T &lt;: Tree](
<i class="no-highlight">128</i>&nbsp;      original: Term,
<i class="no-highlight">129</i>&nbsp;      f: String =&gt; Term,
<i class="no-highlight">130</i>&nbsp;      mutated: MethodExpression
<i class="no-highlight">131</i>&nbsp;  ): PlaceableTree =&gt; Either[Vector[IgnoredMutation[ScalaAST]], Vector[MutatedCode[ScalaAST]]] = {
<i class="no-highlight">132</i>&nbsp;    val replacements: Vector[MethodExpression] = Vector(mutated)
<i class="no-highlight">133</i>&nbsp;    buildMutations[MethodExpression](original, replacements, _(f))
<i class="no-highlight">134</i>&nbsp;  }
<i class="no-highlight">135</i>&nbsp;
<i class="no-highlight">136</i>&nbsp;  private def createMutations[T &lt;: Term](
<i class="no-highlight">137</i>&nbsp;      original: Term,
<i class="no-highlight">138</i>&nbsp;      mutated: Either[IgnoredMutation[ScalaAST], Vector[RegularExpression]]
<i class="no-highlight">139</i>&nbsp;  ): PlaceableTree =&gt; Either[Vector[IgnoredMutation[ScalaAST]], Vector[MutatedCode[ScalaAST]]] = { placeableTree =&gt;
<i class="no-highlight">140</i>&nbsp;    import cats.syntax.either.*
<i class="no-highlight">141</i>&nbsp;
<i class="no-highlight">142</i>&nbsp;    mutated
<i class="no-highlight">143</i>&nbsp;      .leftMap(Vector(_))
<i class="no-highlight">144</i>&nbsp;      .flatMap(muts =&gt; buildMutations[RegularExpression](original, muts, _.tree)(placeableTree))
<i class="no-highlight">145</i>&nbsp;  }
<i class="no-highlight">146</i>&nbsp;
<i class="no-highlight">147</i>&nbsp;  private def buildMutations[T &lt;: Mutation[? &lt;: Tree]](
<i class="no-highlight">148</i>&nbsp;      original: Term,
<i class="no-highlight">149</i>&nbsp;      replacements: Vector[T],
<i class="no-highlight">150</i>&nbsp;      mutationToTerm: T =&gt; Term
<i class="no-highlight">151</i>&nbsp;  ): PlaceableTree =&gt; Either[Vector[IgnoredMutation[ScalaAST]], Vector[MutatedCode[ScalaAST]]] = placeableTree =&gt; {
<i class="no-highlight">152</i>&nbsp;    val mutations = replacements.map { replacement =&gt;
<i class="no-highlight">153</i>&nbsp;      val location: model.elements.Location = replacement match {
<i class="no-highlight">154</i>&nbsp;        case r: RegularExpression =&gt;
<i class="no-highlight">155</i>&nbsp;          val loc = r.location
<i class="no-highlight">156</i>&nbsp;          val start = loc.start
<i class="no-highlight">157</i>&nbsp;          val end = loc.end
<i class="no-highlight">158</i>&nbsp;
<i class="no-highlight">159</i>&nbsp;          new model.elements.Location(
<i class="no-highlight">160</i>&nbsp;            new model.elements.Position(start.line, start.column),
<i class="no-highlight">161</i>&nbsp;            new model.elements.Position(end.line, end.column)
<i class="no-highlight">162</i>&nbsp;          )
<i class="no-highlight">163</i>&nbsp;        case _ =&gt;
<i class="no-highlight">164</i>&nbsp;          val loc = original.pos.toLocation
<i class="no-highlight">165</i>&nbsp;          val start = loc.start
<i class="no-highlight">166</i>&nbsp;          val end = loc.end
<i class="no-highlight">167</i>&nbsp;
<i class="no-highlight">168</i>&nbsp;          new model.elements.Location(
<i class="no-highlight">169</i>&nbsp;            new model.elements.Position(start.line, start.column),
<i class="no-highlight">170</i>&nbsp;            new model.elements.Position(end.line, end.column)
<i class="no-highlight">171</i>&nbsp;          )
<i class="no-highlight">172</i>&nbsp;
<i class="no-highlight">173</i>&nbsp;      }
<i class="no-highlight">174</i>&nbsp;
<i class="no-highlight">175</i>&nbsp;      val tree: Tree = mutationToTerm(replacement)
<i class="no-highlight">176</i>&nbsp;      val metadata = new MutantMetaData(original.syntax, tree.syntax, replacement.mutationName, location)
<i class="no-highlight">177</i>&nbsp;      val mutatedTopStatement = placeableTree.tree
<i class="no-highlight">178</i>&nbsp;        .transformExactlyOnce {
<i class="no-highlight">179</i>&nbsp;          case t if t.isEqual(original) &amp;&amp; t.pos == original.pos =&gt;
<i class="no-highlight">180</i>&nbsp;            tree
<i class="no-highlight">181</i>&nbsp;        }
<i class="no-highlight">182</i>&nbsp;        .getOrElse(
<i class="no-highlight">183</i>&nbsp;          throw new RuntimeException(
<i class="no-highlight">184</i>&nbsp;            s&quot;Could not transform &#39;$original&#39; in ${placeableTree.tree} (${metadata.showLocation})&quot;
<i class="no-highlight">185</i>&nbsp;          )
<i class="no-highlight">186</i>&nbsp;        )
<i class="no-highlight">187</i>&nbsp;
<i class="no-highlight">188</i>&nbsp;      mutatedTopStatement match {
<i class="no-highlight">189</i>&nbsp;        case t: Term =&gt; new MutatedCode(new ScalaAST(value = t), metadata)
<i class="no-highlight">190</i>&nbsp;        case t =&gt;
<i class="no-highlight">191</i>&nbsp;          throw new RuntimeException(
<i class="no-highlight">192</i>&nbsp;            s&quot;Could not transform &#39;$original&#39; in ${placeableTree.tree} (${metadata.showLocation}). Expected a Term, but was a ${t.getClass().getSimpleName}&quot;
<i class="no-highlight">193</i>&nbsp;          )
<i class="no-highlight">194</i>&nbsp;      }
<i class="no-highlight">195</i>&nbsp;
<i class="no-highlight">196</i>&nbsp;    }
<i class="no-highlight">197</i>&nbsp;
<i class="no-highlight">198</i>&nbsp;    filterExclusions(mutations, replacements.head, original)
<i class="no-highlight">199</i>&nbsp;  }
<i class="no-highlight">200</i>&nbsp;
<i class="no-highlight">201</i>&nbsp;  private def filterExclusions(
<i class="no-highlight">202</i>&nbsp;      mutations: Vector[MutatedCode[ScalaAST]],
<i class="no-highlight">203</i>&nbsp;      mutationType: Mutation[?],
<i class="no-highlight">204</i>&nbsp;      original: Tree
<i class="no-highlight">205</i>&nbsp;  ): Either[Vector[IgnoredMutation[ScalaAST]], Vector[MutatedCode[ScalaAST]]] = {
<i class="no-highlight">206</i>&nbsp;    val mutationName = &quot;stryker4jvm.mutation.&quot; + mutationType.mutationName
<i class="no-highlight">207</i>&nbsp;
<i class="no-highlight">208</i>&nbsp;    if (excludedByConfig(mutationType.mutationName) || excludedByAnnotation(original, mutationName))
<i class="no-highlight">209</i>&nbsp;      Left(mutations.map(new IgnoredMutation[ScalaAST](_, new model.IgnoredMutationReason.MutationExcluded)))
<i class="no-highlight">210</i>&nbsp;    else
<i class="no-highlight">211</i>&nbsp;      Right(mutations)
<i class="no-highlight">212</i>&nbsp;  }
<i class="no-highlight">213</i>&nbsp;
<i class="no-highlight">214</i>&nbsp;  private def excludedByConfig(mutation: String): Boolean = config.getExcludedMutations().contains(mutation)
<i class="no-highlight">215</i>&nbsp;
<i class="no-highlight">216</i>&nbsp;  @tailrec
<i class="no-highlight">217</i>&nbsp;  private def excludedByAnnotation(original: Tree, mutationName: String): Boolean = {
<i class="no-highlight">218</i>&nbsp;    import stryker4jvm.mutator.scala.extensions.TreeExtensions.*
<i class="no-highlight">219</i>&nbsp;    original.parent match {
<i class="no-highlight">220</i>&nbsp;      case Some(value) =&gt;
<i class="no-highlight">221</i>&nbsp;        value.getMods.exists(isSupressWarningsAnnotation(_, mutationName)) || excludedByAnnotation(
<i class="no-highlight">222</i>&nbsp;          value,
<i class="no-highlight">223</i>&nbsp;          mutationName
<i class="no-highlight">224</i>&nbsp;        )
<i class="no-highlight">225</i>&nbsp;      case None =&gt; false
<i class="no-highlight">226</i>&nbsp;    }
<i class="no-highlight">227</i>&nbsp;  }
<i class="no-highlight">228</i>&nbsp;
<i class="no-highlight">229</i>&nbsp;  private def isSupressWarningsAnnotation(mod: Mod, mutationName: String): Boolean = {
<i class="no-highlight">230</i>&nbsp;    mod match {
<i class="no-highlight">231</i>&nbsp;      case Mod.Annot(Init(Type.Name(&quot;SuppressWarnings&quot;), _, List(List(Term.Apply(Name(&quot;Array&quot;), params))))) =&gt;
<i class="no-highlight">232</i>&nbsp;        params.exists {
<i class="no-highlight">233</i>&nbsp;          case Lit.String(`mutationName`) =&gt; true
<i class="no-highlight">234</i>&nbsp;          case _                          =&gt; false
<i class="no-highlight">235</i>&nbsp;        }
<i class="no-highlight">236</i>&nbsp;      case _ =&gt; false
<i class="no-highlight">237</i>&nbsp;    }
<i class="no-highlight">238</i>&nbsp;  }
<i class="no-highlight">239</i>&nbsp;}
</div>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
        var codeBlock = document.getElementById('sourceCode');

        if (codeBlock) {
            hljs.highlightBlock(codeBlock);
        }
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-01-25 13:10</div>
</div>
</body>
</html>
