package stryker4jvm.mutator.scala

import stryker4jvm.core.model.Collector
import stryker4jvm.core.model.CollectedMutants
import stryker4jvm.core.model.CollectedMutants.IgnoredMutation

import scala.meta.Tree

import stryker4jvm.core.model.MutatedCode
import scala.collection.mutable.Map

import scala.collection.JavaConverters.*
import java.util as ju
import stryker4jvm.core.logging.Logger

import stryker4jvm.mutator.scala.extensions.TreeExtensions.*

/** Class that is used to collect mutants in an AST
  *
  * @param traverser
  *   Used to traverse through an AST
  * @param matcher
  *   Used to check if a mutation can be placed on a given PlaceableTree
  * @param log
  */
class ScalaCollector(
    val traverser: Traverser,
    val matcher: MutantMatcher
)(implicit log: Logger)
    extends Collector[ScalaAST] {

  /** The actual method that collects the mutants
    *
    * @param ast
    *   A ScalaAST of the input file (generated by [[stryker4jvm.mutator.scala.ScalaParser]])
    * @return
    *   All the collected mutants in the given AST (also includes excluded mutants)
    */
  override def collect(ast: ScalaAST): CollectedMutants[ScalaAST] = {
    val tree = ast.value;

    if (tree == null) {
      log.error("Tree is null");
      return null;
    }

    // PartialFunction to check if the currently-visiting tree node is a node where we can place mutants
    val canPlaceF: PartialFunction[Tree, PlaceableTree] = Function.unlift(traverser.canPlace).andThen(PlaceableTree(_))

    // PartialFunction that _sometimes_ matches and returns the mutations at a PlaceableTree `NonEmptyList[Mutant]`
    val onEnterF = matcher.allMatchers.andThen(f => (p: PlaceableTree) => p -> f(p))

    // Walk through the tree and create a Map of PlaceableTree and Mutants
    val collected: List[(PlaceableTree, Either[Vector[IgnoredMutation[ScalaAST]], Vector[MutatedCode[ScalaAST]]])] =
      tree.collectWithContext(canPlaceF)(onEnterF)

    // Get mutations and ignoredmutations in correct format to return
    var ignoredMutations: Vector[IgnoredMutation[ScalaAST]] = Vector()
    var mutations = Map[ScalaAST, ju.List[MutatedCode[ScalaAST]]]()

    for (col <- collected) {
      val placeableTree = col._1
      col._2 match {
        case Left(value) => ignoredMutations = ignoredMutations ++ value
        case Right(mutants) =>
          val ast = new ScalaAST(value = placeableTree.tree);

          if (mutations.contains(ast)) {
            var muts = mutations.get(ast).get.asScala.toVector;
            muts ++= mutants;

            mutations = mutations + (ast -> muts.asJava)
          } else {
            mutations = mutations + (ast -> mutants.asJava)
          }
      }
    }

    new CollectedMutants[ScalaAST](ignoredMutations.asJava, mutations.asJava)
  }

}
